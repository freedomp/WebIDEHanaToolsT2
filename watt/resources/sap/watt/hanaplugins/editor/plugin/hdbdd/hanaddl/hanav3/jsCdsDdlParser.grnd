//based on /SAPDevelop/HDB/git/sys/src/cds/compiler/parses/CDS.grnd
//commit b3b6d2bf8745f9537eee43c6c825e3861a1954b7
//Author: Hans-Joachim Both <h.both@sap.com>
//Date:   Wed Nov 5 18:08:13 2014 +0100
//
//    CDS Compiler/Activator/Catalog:

options {
    maxSuspiciousMatches = 2;
    sloppyNames           = true;
    warningLevel          = 1;
}

// any keyword wildcard
TOK_DEF(_C("#ANYKW#"), NUM_ANYKW)
// any literal wildcard
TOK_DEF(_C("#ANYLIT#"), NUM_ANYLIT)
// whitespace stuff
TOK_DEF(_C("#EOF#"), NUM_EOF)
TOK_DEF(_C("#NL#"), NUM_NL)
TOK_DEF(_C("#COMMENT1#"), NUM_COMMENT1)
TOK_DEF(_C("#COMMENT2#"), NUM_COMMENT2)
// for obscure reasons, the tokens above shall not be changed!
TOK_DEF(_C("."), DOT)
TOK_DEF(_C(".."), DDOT_OP)
TOK_DEF(_C(","), COMMA)
TOK_DEF(_C(":"), NUM_COLON)
TOK_DEF(_C("::"), DCOLON)
TOK_DEF(_C(";"), SEMICOLON)
TOK_DEF(_C("@"), AT)
TOK_DEF(_C("("), LPAREN)
TOK_DEF(_C(")"), RPAREN)
TOK_DEF(_C("{"), LCURLY)
TOK_DEF(_C("}"), RCURLY)
TOK_DEF(_C("="), EQ_OP)
TOK_DEF(_C("<"), LT_OP)
TOK_DEF(_C(">"), GT_OP)
TOK_DEF(_C("<="), LE_OP)
TOK_DEF(_C(">="), GE_OP)
TOK_DEF(_C("<>"), NE_OP)
TOK_DEF(_C("=>"), NAMED_PARAM_ASSIGN_OP)
TOK_DEF(_C("||"), CONCAT_OP)
TOK_DEF(_C("["), NUM_LBRACK)
TOK_DEF(_C("]"), NUM_RBRACK)
TOK_DEF(_C("#STR_CONST#"), NUM_STR_CONST)
TOK_DEF(_C("#INT_CONST#"), NUM_INT_CONST)
TOK_DEF(_C("#REAL_CONST#"), NUM_REAL_CONST)
TOK_DEF(_C("#DATE_CONST#"), NUM_DATE_CONST)
TOK_DEF(_C("#TIME_CONST#"), NUM_TIME_CONST)
TOK_DEF(_C("#TIMESTAMP_CONST#"), NUM_TIMESTAMP_CONST)
TOK_DEF(_C("#BINARY_CONST#"), NUM_BINARY_CONST)
TOK_DEF(_C("*"), NUM_STAR)
TOK_DEF(_C("?"), NUM_QUESTION)
TOK_DEF(_C("+"), NUM_PLUS)
TOK_DEF(_C("-"), MINUS_OP)
TOK_DEF(_C("/"), DIV_OP)
TOK_DEF(_C("$"), NUM_DOLLAR)

// ID is the end of reserved keywords list
// THE ID
TOK_DEF(_C("#ID#"), NUM_ID)

target JsResolver {
	language = JavaScript;
	generatedResolver = "CdsDdlParserResolver.js";
	generatedPad = "CdsDdlParserJs.pad";
}

@JsResolver::header {{{

/*eslint-disable */
define(
["hanaddl/hanaddlNonUi","rndrt/rnd","commonddl/commonddlNonUi"], //dependencies
function (hanaddlNonUi,rnd,commonddlNonUi) {

var StdFuncExpressionImpl = commonddlNonUi.StdFuncExpressionImpl;
var SelectListImpl = commonddlNonUi.SelectListImpl;
var ExpressionContainerImpl = commonddlNonUi.ExpressionContainerImpl;
var GroupByImpl = commonddlNonUi.GroupByImpl;
var PathEntryImpl = commonddlNonUi.PathEntryImpl;
var ExpressionImpl = commonddlNonUi.ExpressionImpl;
var OrderByImpl = commonddlNonUi.OrderByImpl;
var AnnotationValueImpl = commonddlNonUi.AnnotationValueImpl;
var PathExpressionImpl = commonddlNonUi.PathExpressionImpl;
var LiteralExpressionImpl = commonddlNonUi.LiteralExpressionImpl;
var Token = rnd.Token;
var ForeignKeyImpl = commonddlNonUi.ForeignKeyImpl;
var OrderByEntryImpl = commonddlNonUi.OrderByEntryImpl;
var AttributeDeclarationImpl = commonddlNonUi.AttributeDeclarationImpl;
var AbstractAnnotationValueImpl = commonddlNonUi.AbstractAnnotationValueImpl;
var CaseWhenExpressionImpl = commonddlNonUi.CaseWhenExpressionImpl;
var DataSourceImpl = commonddlNonUi.DataSourceImpl;
var ViewSelectSetImpl = commonddlNonUi.ViewSelectSetImpl;
var BaseCdsDdlParser = hanaddlNonUi.BaseCdsDdlParser;
var IAstFactory = commonddlNonUi.IAstFactory;
var Stackframe = rnd.Stackframe;
var Parser = rnd.Parser;
var FramePtr = rnd.FramePtr;
var NullFrame = rnd.NullFrame;
var UserStackframeT = rnd.UserStackframeT;

  function CdsDdlParserResolver(byte_code, scanner) {
        BaseCdsDdlParser.call(this,byte_code, scanner);
        this.m_start_attr = new rnd.NullFrame();
    }
    CdsDdlParserResolver.prototype = Object.create(BaseCdsDdlParser.prototype);

}}}

////////////////////////////////////////
// Main logic
////////////////////////////////////////

Colon :
    ":" | #COLON_FOLLOWED_BY_ID# ;


// take care of re-naming this rule name; its name is referenced in VersionsFactory#setErrorRecoveryHook
START
    @init
    {
RESOLVER.initializeParser();
}
    :
    ( START2 | NEVER_MATCH_RULE )+  %COMMIT
;

// take care of re-naming this rule name; its name is referenced in VersionsFactory#setErrorRecoveryHook
NEVER_MATCH_RULE: //introduced for error recovery -> word completion should work when statements are invalid
   	#ID# "never" "match" "this" "rule" ";" %COMMIT
;

// take care of re-naming this rule name; its name is referenced in VersionsFactory#setErrorRecoveryHook
START2:
	(
        NamespaceDeclaration
    )?
    (
		UsingDirectiveList
    )?
    (
        TopLevelDeclaration[null]
    )
    %COMMIT
;

//start rule for syntax coloring (no AST creation)
// support also element declarations as part of start rule
START_SYNTAX_COLORING
options{
	startrule = "TRUE";
}
:
	( 	START2 |
		AnnotatedElementDeclaration[null] |
		NEVER_MATCH_RULE |
		(
			"}" ";" // for end of type/entitiy declaration (damage repairer goes only back to last ";" -> therefore rest could be "};" -> strategy is to parse as less as possible (for performance reasons)
		)
	)+  %COMMIT
;


NamespaceDeclaration returns[INamespaceDeclaration cdecl]
	@init{
		IPathDeclaration path = null;
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    NAMESPACE
    {
$path = RESOLVER.createPathDeclaration();
}
    NamespacePath[path]
    {
$$.cdecl = RESOLVER.createNamespace($path);
RESOLVER.setRootNamespace($$.cdecl);
}
    ";"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.cdecl,$startIndex,$endIndex);
}
    %COMMIT
;

UsingDirectiveList:
    (
        directive = UsingDirective
        {
RESOLVER.compilationUnit.getStatements().push($directive.res);
}
    )+
;

//this rule name is used in DdlErrorRecoveryHook
UsingDirective returns [IUsingDirective res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    "using"
    path = PathWithNamespace
    (
        AS alias = IdWrapper
    )?
    ";"
    {
$$.res = RESOLVER.createUsingDirective($path.res,$alias.res);
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
    %COMMIT
;


// One file contains just one single top-level declaration
// take care of re-naming this rule name; its name is referenced in VersionsFactory#setErrorRecoveryHook
TopLevelDeclaration
[List<IPreAnnotation> preAnnotations]
:
   	{
$$.preAnnotations = RESOLVER.createPreAnnotationList();
}
    (
        annotation = PreAnnotation
        {
RESOLVER.collectPreAnnotation($$.preAnnotations,$annotation.res);
}
    ) *
    DEFINE ?
    (
        (
            c_decl = ContextDeclaration[$$.preAnnotations,RESOLVER.compilationUnit.getStatements()]
        )
        |
        (
			AccessPolicyDeclaration[$$.preAnnotations, RESOLVER.compilationUnit.getStatements()]
        )
        |
        (
            e_decl = EntityDeclaration[$$.preAnnotations, RESOLVER.compilationUnit.getStatements()]
        )
        |
        (
            v_decl = ViewDeclaration[$$.preAnnotations, RESOLVER.compilationUnit.getStatements()]
        )
        |
        (
            t_decl = TypeDeclaration[$$.preAnnotations, RESOLVER.compilationUnit.getStatements()]
        )
        |
        (
            co_decl = ConstDeclaration[$$.preAnnotations, RESOLVER.compilationUnit.getStatements()]
        )
        |
        (
            annot_decl = AnnotationDeclaration[$$.preAnnotations, RESOLVER.compilationUnit.getStatements()]
        )
    )
;

// take care of re-naming this rule name; its name is referenced in VersionsFactory#setErrorRecoveryHook
ContextDeclaration
		[List<IPreAnnotation> annots,List<IDdlStatement> parentStmts]
returns [IContextDeclaration res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
		
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}

    CONTEXT
    id = QualifiedDefId
	{
$$.res = RESOLVER.createContext($id);
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,-1);
RESOLVER.addAnnotations($$.res,$$.annots);
if ($$.parentStmts != null) {
$$.parentStmts.push($$.res);
}
}
    "{"
    %COMMIT
    (
        ContextComponentDeclaration[null, $$.res]
    )*
    "}"
    ";"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
    %COMMIT
;

// take care of re-naming this rule name; its name is referenced in VersionsFactory#setErrorRecoveryHook
ContextComponentDeclaration
[ List<IPreAnnotation> preAnnotations, IContextDeclaration context]
	@init{
		List<IDdlStatement> stmts = null;
	}
:
   	{
$$.preAnnotations = RESOLVER.createPreAnnotationList();
}
   	%COMMIT
    (
        annotation = PreAnnotation
        {
RESOLVER.collectPreAnnotation($$.preAnnotations,$annotation.res);
}
    ) *
	DEFINE ?
    (
        (
        	{
if ($$.context != null) {
$stmts = $$.context.getStatements();
}
}
            c_decl = ContextDeclaration[$$.preAnnotations,$stmts]
        )
        |
        (
        	{
if ($$.context != null) {
$stmts = $$.context.getStatements();
}
}
            t_decl = TypeDeclaration[$$.preAnnotations,$stmts]
        )
        |
        (
        	{
if ($$.context != null) {
$stmts = $$.context.getStatements();
}
}
            e_decl = EntityDeclaration[$$.preAnnotations,$stmts]
        )
        |
        (
        	{
if ($$.context != null) {
$stmts = $$.context.getStatements();
}
}
            v_decl = ViewDeclaration[$$.preAnnotations,$stmts]
        )
        |
        (
        	{
if ($$.context != null) {
$stmts = $$.context.getStatements();
}
}
            co_decl = ConstDeclaration[$$.preAnnotations,$stmts]
        )
		|
        (
        	{
if ($$.context != null) {
$stmts = $$.context.getStatements();
}
}
            annot_decl = AnnotationDeclaration[$$.preAnnotations,$stmts]
        )
    )
    %COMMIT  //!!! maybe not needed
;

//This rulename is used in code completion logic. Consider this when you change.
AccessPolicyDeclaration
	[List<IPreAnnotation> annots,List<IDdlStatement> parentStmts]
	returns [IAccessPolicyDeclaration res]
	@init{
		IAccessPolicyDeclaration res = null;
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    "accesspolicy"
    id = QualifiedDefId
    {
$res = RESOLVER.createAccessPolicy($id);
parentStmts.push($res);
RESOLVER.viewparser_setStartEndTokenIndex($res,$startIndex,-1);
RESOLVER.addAnnotations($res,$$.annots);
}
    "{"
    (
        n2 = AccessPolicyComponentDeclaration[$res]
    ) *
    "}"
    ";"
	{
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($res,$startIndex,$endIndex);
}
    %COMMIT
;

//This rulename is used in code completion logic. Consider this when you change.
AccessPolicyComponentDeclaration[IAccessPolicyDeclaration parent]
	@init{
		List<IPreAnnotation> preAnnotations = null;
	}
:
   	{
$preAnnotations = RESOLVER.createPreAnnotationList();
}
   	%COMMIT
    (
        annotation = PreAnnotation
        {
RESOLVER.collectPreAnnotation($preAnnotations,$annotation.res);
}
    ) *
    DEFINE ?
    (
        (
            r_decl = RoleDeclaration[$preAnnotations, $$.parent]
            |
            a_decl = AspectDeclaration[$preAnnotations, $$.parent, null]
        )
    )
;

RoleDeclaration
	[List<IPreAnnotation> preAnnotations, IStatementContainer statementContainer]
	@init{
		int startIndex = 0;
		int endIndex = 0;
		int subElementStartIndex = 0;
		IRoleDeclaration role = null;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    "role"
    id = QualifiedDefId
    {
$role = RESOLVER.createRole($id);
RESOLVER.viewparser_setStartEndTokenIndex($role,$startIndex,-1);
RESOLVER.addAnnotations($role,$$.preAnnotations);
if (statementContainer != null) {
statementContainer.getStatements().push($role);
}
}
    "{"
    (
		RuleDeclaration[$role]
    )* //backend uses  "+". Let's be more tolerant on the client.
    "}"
    ";"
	{
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($role,$startIndex,$endIndex);
}
    %COMMIT
;

RuleDeclaration[IRoleDeclaration role]
	@init{
		int startIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
	"grant"
	(
		(
			rule = RuleSubquery[$$.role,$startIndex]
		)
/*      Not supported in SP9
		|
		(
			incl = RuleIncludedRole[$$.role]
		)
*/
	)
	|
	(
		DEFINE ?
		a_decl = AspectDeclaration[null,null,$$.role]
	)
;

RuleIncludedRole[IRoleDeclaration parent]
	@init{
		int startIndex = 0;
		int endIndex = 0;
		IIncludedRole includedRole = null;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
	role = PathSimple
	{
$includedRole = RESOLVER.createIncludedRole($role.res);
if (parent != null) {
parent.getEntries().push($includedRole);
}
}
	";"
	{
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($includedRole,$startIndex,$endIndex);
}
    %COMMIT
;

//This rulename is used in code completion logic. Consider this when you change.
RuleSubquery[IRoleDeclaration parent,int startIndex]
	@init{
		int endIndex = 0;
		IRuleDeclaration rule = null;
	}
:
    {
$rule = RESOLVER.createRule();
RESOLVER.viewparser_setStartEndTokenIndex($rule,$startIndex,-1);
if ($$.parent != null) {
$$.parent.getEntries().push($rule);
}
}
    from = RuleFromClause[$rule]
    where = WhereClause[null]
    {
$rule.setWhere($where.res);
}
    ";"
	{
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($rule,$$.startIndex,$endIndex);
}
    %COMMIT
;

//This rulename is used in code completion logic. Consider this when you change.
RuleFromClause [IRuleDeclaration rule]
	@init{
		IRuleFromClause from = null;
	}
:
    (  // both variant a semantically the same. It's only syntactic sugar!
        (
            sel1="select"  // later on other SQL commands like "INSERT" may follow
            on="on"
            {
$from = RESOLVER.createPrefixRuleFromClause(TOK(sel1),TOK(on));
$$.rule.setFrom($from);
}
           	path1 = QLPath
			{
var dsPath = RESOLVER.viewparser_tableDatasource($path1.res);
$from.setDataSource(dsPath);
}
        )
        |
        (
           	path2 = QLPath
            "."
            sel2="select"  // later on other SQL commands like "INSERT" may follow
            {
$from = RESOLVER.createPostfixRuleFromClause(TOK(sel2));
$$.rule.setFrom($from);
var dsPath = RESOLVER.viewparser_tableDatasource($path2.res);
$from.setDataSource(dsPath);
}
        )
    )
    %COMMIT
;

//This rulename is used in code completion logic. Consider this when you change.
AspectDeclaration
	[List<IPreAnnotation> preAnnotations, IStatementContainer statementContainer,IRoleDeclaration role]
	@init{
		int startIndex = 0;
		int endIndex = 0;
		IAspectDeclaration aspect = null;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
	"aspect"
    id = QualifiedDefId
    {
$aspect = RESOLVER.createAspect($id);
RESOLVER.viewparser_setStartEndTokenIndex($aspect,$startIndex,-1);
RESOLVER.addAnnotations($aspect,$$.preAnnotations);
if ($$.statementContainer != null) {
$$.statementContainer.getStatements().push($aspect);
}else if ($$.role != null) {
$$.role.getEntries().push($aspect);
}
}
    AS
	ql_query_decl = QLSubqueryElementary[$aspect,null]
    ";"
	{
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($aspect,$startIndex,$endIndex);
}
    %COMMIT
;

// take care of re-naming this rule name; its name is referenced in VersionsFactory#setErrorRecoveryHook
EntityDeclaration
		[List<IPreAnnotation> annots,List<IDdlStatement> parentStmts]
returns [IEntityDeclaration res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    ENTITY
    id = QualifiedDefId
    "{"
    %COMMIT
	{
$$.res = RESOLVER.createEntity($id);
if ($$.parentStmts != null) {
$$.parentStmts.push($$.res);
}
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,-1);
RESOLVER.addAnnotations($$.res,$$.annots);
}
	AnnotatedElementDeclarationLoop[$$.res]
    "}"
    ";"   // Temporary SP5 restriction: Semicolon is "optional" according spec
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
    %COMMIT
;

AnnotatedElementDeclarationLoop [IEntityDeclaration res]:
	%COMMIT //needed for error recovery
	(
        AnnotatedElementDeclaration[$$.res]
    ) *  //changed to "optional" to also get an AST for empty entities
;

// take care of re-naming this rule name; its name is referenced in VersionsFactory#setErrorRecoveryHook
ViewDeclaration
		[List<IPreAnnotation> annots,List<IDdlStatement> parentStmts]
returns [IViewDefinition res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    VIEW
    id = QualifiedDefId
    {
$$.res = RESOLVER.viewparser_startDefineView();
$$.res.setNamePath($id.res);
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,-1);
RESOLVER.addAnnotations($$.res,$$.annots);
if ($$.parentStmts != null) {
$$.parentStmts.push($$.res);
}
}
    // ParameterDeclarationList[res]? // not yet released in HANA server
    AS
	QLSelectStmtNoOption[$$.res]
    ";"   // Temporary SP5 restriction: Semicolon is "optional" according spec

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
    %COMMIT
;

AnnotatedElementDeclaration [IComponentDeclaration parent]
	@init{
		List<IPreAnnotation> preAnnotations = null;
	}
:
    {
$preAnnotations = RESOLVER.createPreAnnotationList();
}
    (
        annot = PreAnnotation
        {
RESOLVER.collectPreAnnotation($preAnnotations,$annot.res);
}
    ) *
    ElementDeclaration[$$.parent, $preAnnotations]
;

ElementDeclaration [IComponentDeclaration parent, List<IPreAnnotation> preAnnots]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    modifiers:ElementModifier?
    element:ELEMENT ?
    id = DefId
    type = TypeSpec[$$.parent,$id.res]
    {
RESOLVER.addAnnotations($type.res,$$.preAnnots);
RESOLVER.initializeElement($type.res,id,$modifiers.keyToken,null,$element.name,null);
}
    <
        Nullability[$type.res] ?
        DefaultClause[$type.res] ?
    >
    ";"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($type.res,$startIndex,$endIndex);
}
    %COMMIT
;

Nullability [IElementDeclaration res] :
    (
        (
            no:NOT
            {
RESOLVER.setNotToken($$.res,$no.name);
}
        ) ?
        nu:NULL
        {
RESOLVER.setNullableToken($$.res,$nu.name);
}
    )
;

DefaultClause [IElementDeclaration res] :
    (
    	DEFAULT
        (
	        (
		        expr = Expression
		        {
RESOLVER.viewparser_setElementDefault($$.res,$expr.res);
}
			)
	        |
	        (
	        	enumVal = EnumIdWrapper //Christoph W.: EnumId should be handled inside Expressions later on. If this changes, we have to change the error recovery accordingly.
	        	{
RESOLVER.viewparser_setElementDefaultToken($$.res,$enumVal.res);
}
	        )
        )
    )
;


ElementModifier returns [Token keyToken] :
    (
        key:KEY
        {
$$.keyToken = $key.name;
}
    )
;

ConstDeclaration
		[List<IPreAnnotation> annots,List<IDdlStatement> parentStmts]
returns [IConstDeclaration res]
	@init{
		int startIndex;
		int endIndex;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    "const"
    id = QualifiedDefId
    {
$$.res = RESOLVER.createConst($id.res);
if ($$.parentStmts != null) {
$$.parentStmts.push($$.res);
}
RESOLVER.addAnnotations($$.res,$$.annots);
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,-1);
}
    (
        type = TypeSpec[$$.res,null]
    )?
    // Semantic check currently allows only literals and unary '+' and '-' expressions here
    "=" expr = ConstValue
    {
RESOLVER.viewparser_setConstValue($$.res,$expr.res);
}
    ";"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
    %COMMIT
;

ConstValue returns [IExpression res]:
	exp = Expression
	{
$$.res = $exp.res;
}
;

EnumValueDeclaration returns [IEnumerationValue res]
	@init{
		int startIndex;
		int endIndex;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    id = DefId
    {
$$.res = IAstFactory.eINSTANCE.createEnumerationValue();
$$.res.setSymbol($id.res);
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,-1);
}
    "=" expr = Expression
    {
if ($expr.res instanceof LiteralExpressionImpl) {
$$.res.setLiteral($expr.res);
}
}
    ";"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
    %COMMIT
;

TypeDeclaration
		[List<IPreAnnotation> annots,List<IDdlStatement> parentStmts]
returns	[ITypeDeclaration res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    TYPE
    id = QualifiedDefId
    {
$$.res = RESOLVER.createType($id);
if ($$.parentStmts != null) {
$$.parentStmts.push($$.res);
}
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,-1);
RESOLVER.addAnnotations($$.res,$$.annots);
}
    (
        StructuredType[$$.res]  // in the backend this is contaied in typeSpec. But it's only allowed in TypeDeclarations and AnnotationDeclaration not at the other usages of TypeSpec
    |
	    typespec = TypeSpec[$$.res,null]
 	)
    ";"   // Temporary SP5 restriction: Semicolon is "optional" according spec
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
    %COMMIT
;

// take care of re-naming this rule name; its name is referenced in VersionsFactory#setErrorRecoveryHook
StructuredType [IComponentDeclaration res] :
    "{"
    %COMMIT
    StructuredTypeComponent[$$.res]
    "}"
;

StructuredTypeComponent [IComponentDeclaration res] :
	(
        typecomponent = AnnotatedTypeComponentDeclaration[$$.res]
        {
if ($$.res != null) {
RESOLVER.addTypeElement($$.res,$typecomponent.res);
}
}
		%COMMIT
    ) *
;


AnnotatedTypeComponentDeclaration[IComponentDeclaration parent ] returns [IElementDeclaration res,List<IPreAnnotation> preAnnotations]
    :
    {
$$.preAnnotations = RESOLVER.createPreAnnotationList();
}
    (
        annot = PreAnnotation
     	{
RESOLVER.collectPreAnnotation($$.preAnnotations,$annot.res);
}
    ) *
    typeCompDecl = TypeComponentDeclaration[$$.parent]
    {
$$.res = $typeCompDecl.res;
RESOLVER.addAnnotations($$.res,$$.preAnnotations);
}
    %COMMIT
;

TypeComponentDeclaration[IComponentDeclaration parent ] returns [IElementDeclaration res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
	element:ELEMENT ?
    id = DefId
    typespec = TypeSpec[$$.parent,$id.res]
    {
$$.res = $typespec;
RESOLVER.initializeTypeComponent($$.res,$id.res,$element.name);
}
    DefaultClause[$$.res] ?
    ";"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
    %COMMIT
;

// take care of re-naming this rule name; its name is referenced in VersionsFactory#setErrorRecoveryHook
// There's a copy of this rule "AnnotationTypeSpec" that is used in AnnotationDefinition.
// It needed to be copied because the AST for Annotations is completely different - putting both into one rule
// would be to complicated. Nobody would understand it afterwards
TypeSpec [IComponentDeclaration parent,Token def] returns [IElementDeclaration res]
	@init{
		int startIndex;
	}
:
    (
	    Colon
	    {
$startIndex = RESOLVER.getNextTokenIndex();
}

	    (
	        tto = TypeTypeOf[$$.parent,$$.def]
	        {
$$.res = $tto;
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,-1);
}
	    |
			/* we have to support "array of" inside type declarations which then can be used inside annotation definitions.
			   array of inside entities are not allowed. We therefore don't propose array of in coco. */
			arr = TypeArray[$$.parent,$$.def]
			{
$$.res = $arr;
}

    	|
	        typename = TypeNamedOrEnum[$$.parent,$$.def]
	        {
$$.res = $typename;
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,-1);
}
	    |
	        typeassoc = TypeAssoc[$$.parent,$$.def]
	        {
$$.res = $typeassoc.res;
}
	    )
	)
	|
	/* Mail from SW:
		Was geht mich mein Geschwätz von gestern an …
		Wir erlauben zu SP09 anonyme Substrukturen in entities und types.
	*/
	(
		{
if ($$.def != null) {
var attribute = RESOLVER.createAttribute(null);
attribute.setNameToken($$.def);
$$.parent.getElements().push(attribute);
$$.parent = RESOLVER.createAndSetAnonymousTypeDeclaration(attribute);
$$.res = attribute;
}
}
		comp_list = StructuredType[$$.parent]
    )
;

// There's a copy of this rule "AnnotationTypeSpecNoColon" that is used in AnnotationDefinition.
// It needed to be copied because the AST for Annotations is completely different - putting both into one rule
// would be to complicated. Nobody would understand it afterwards

TypeSpecNoColon [IComponentDeclaration parent,Token def] returns [IElementDeclaration res]
	@init{
		int startIndex;
	}
:
    (
	    {
$startIndex = RESOLVER.getNextTokenIndex();
}
        tto = TypeTypeOf[$$.parent,$$.def]
        {
$$.res = $tto;
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,-1);
}
   		|
        typename = TypeNamedOrEnum[$$.parent,$$.def]
        {
$$.res = $typename;
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,-1);
}
//    	|												// is inhibited by a semantic check in backend, therefore we don't take it for the frontend grammar
//      typeassoc = TypeAssoc[$$.parent,$$.def]
//      {
//         $$.res = $typeassoc.res;
//      }
	)
	|
	(
		{
if ($$.def != null) {
var attribute = RESOLVER.createAttribute(null);
attribute.setNameToken($$.def);
$$.parent.getElements().push(attribute);
$$.parent = RESOLVER.createAndSetAnonymousTypeDeclaration(attribute);
$$.res = attribute;
}
}
		comp_list = StructuredType[$$.parent]
    )
;

TypeTypeOf [IComponentDeclaration parent,Token def] returns [IAttributeDeclaration res]:
    TYPE OF id = PathSimple
    {
$$.res = RESOLVER.createAttributeTypeOf($id);
if ($$.def != null) {
$$.res.setNameToken($$.def);
}
if ($$.parent != null) {
$$.parent.getElements().push($$.res);
}
}
;

// There's a copy of this rule "AnnotationTypeArray" that is used in AnnotationDefinition.
// It needed to be copied because the AST for Annotations is completely different - putting both into one rule
// would be to complicated. Nobody would understand it afterwards

TypeArray [IComponentDeclaration parent,Token def] returns [IElementDeclaration res] :
	// %CCIGNORE so that "array of" keyword is not proposed because backend doesn't support "array of" inside entity; only in type and annotation supported.
    %CCIGNORE a:"array" %CCIGNORE o:"of" sub = TypeSpecNoColon[$$.parent, $$.def]
    {
$$.res = $sub;
if ($$.res != null) {
$$.res.setArrayToken(TOK(a));
$$.res.setArrayOfToken(TOK(o));
}
}
;

// There's a copy of this rule "AnnotationTypeNamedOrEnum" that is used in AnnotationDefinition.
// It needed to be copied because the AST for Annotations is completely different - putting both into one rule
// would be to complicated. Nobody would understand it afterwards

TypeNamedOrEnum [IComponentDeclaration parent,Token def] returns [IAttributeDeclaration res]
	@init{
		int startIndex;
		int endIndex;
		IEnumerationDeclaration enumeration = null;
	}
:
    named = TypeNamed[$$.parent,$$.def]
    {
$$.res = $named.res;
}
    (
    	{
$startIndex = RESOLVER.getNextTokenIndex();
$enumeration = IAstFactory.eINSTANCE.createEnumerationDeclaration();
$$.res.setEnumerationDeclaration($enumeration);
}
        "enum" "{"
        %COMMIT
        (
            val_decl = EnumValueDeclaration
            {
$enumeration.getValues().push($val_decl.res);
}
        )+
        "}"
        {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($enumeration,$startIndex,$endIndex);
}
    )?
;

// There's a copy of this rule "AnnotationTypeNamed" that is used in AnnotationDefinition.
// It needed to be copied because the AST for Annotations is completely different - putting both into one rule
// would be to complicated. Nobody would understand it afterwards
TypeNamed [IComponentDeclaration parent,Token def] returns [IAttributeDeclaration res]:
    id = TypeName
    {
$$.res = RESOLVER.createAttribute($id);
if ($$.def != null) {
$$.res.setNameToken($$.def);
}
if ($$.parent != null) {
$$.parent.getElements().push($$.res);
}
}
    (
        "("
        p1 = IntLiteralWrapper
        {
$$.res.setLengthToken($p1);
}
        (
            ","
            p2 = IntLiteralWrapper
            {
$$.res.setDecimalsToken($p2);
}
        )?
        ")"
    )?
;

TypeName //this rule name is used in BaseCdsDdlParser. Keep this in mind when re-name-ing or delete-ing this rule
returns [IPathExpression res]
:
	id = PathSimple
	{
$$.res = $id.res;
}
;


AssociationForeignKeys [IAssociationDeclaration res] returns [int startIndex=0,int endIndex=0]:
	"{"
		r = AssociationForeignKeyElement [$$.res]
		{
$$.startIndex = $r.startIndex;
$$.endIndex = $r.endIndex;
}
	"}"
;

AssociationForeignKeyElement [IAssociationDeclaration res] returns [int startIndex=0,int endIndex=0]:
	(
		{
$$.startIndex = RESOLVER.getNextTokenIndex();
}
	    k1 = PathWithAlias
	    {
var fk = RESOLVER.addKey($$.res, $k1.res, $k1.alias);
$$.endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex(fk,$$.startIndex,$$.endIndex);
}
	    (
	    	","
	        {
$$.startIndex = RESOLVER.getNextTokenIndex();
}
	        kn = PathWithAlias
	        {
var fk = RESOLVER.addKey($$.res, $kn.res, $kn.alias);
$$.endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex(fk,$$.startIndex,$$.endIndex);
}
	     )*
	 )?
;

AssociationTo [IComponentDeclaration parent,Token def,IViewSelect select] returns [IAssociationDeclaration res]
	@init{
		int startTargetIndex;
		int endTargetIndex;
	}
:
    ASSOCIATION
    {
$$.res = RESOLVER.createAssociation();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,-1,-1);
if ($$.def != null) {
$$.res.setNameToken($$.def);
}
if ($$.parent != null) {
parent.getElements().push($$.res);
}else if ($$.select != null) {
RESOLVER.addAssociation($$.select,$$.res);
}
}
    Cardinality[$$.res] ?
    TO
    {
$startTargetIndex = RESOLVER.getNextTokenIndex();
}
    target:PathSimple
    {
$endTargetIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($target,$startTargetIndex,$endTargetIndex);
$$.res.setTargetEntityPath($target);
}
;

AssocForeignKeyOrJoinCondition[IAssociationDeclaration assoc]
:
    (
    	(
    		AssociationForeignKeys[$$.assoc]
		|
			AssociationOnCondition[$$.assoc]
		)
    )?
;

AssociationOnCondition [IAssociationDeclaration res]:
	"on"
	cond = Condition
    {
if ($$.res != null) {
$$.res.setOnExpression($cond.res);
}
}
;

TypeAssoc [IComponentDeclaration parent,Token def] returns [IAssociationDeclaration res]:
    assocTo = AssociationTo[$$.parent, $$.def, null]
	{
$$.res = $assocTo.res;
}
    AssocForeignKeyOrJoinCondition[$assocTo.res]
;

Cardinality [IAssociationDeclaration res] returns[Token srcMaxStar, Token maxStar] :
    "["
    (
        () // epsilon production,  "[]" means "[0..*]"
    |

        //here we have backtracking, but performance is
        //not critical at this point, so prefer clear grammar
        //
        // source, maximum
        ( EXPECT ND UPON ( #INT_CONST# , "*" )
            (
               srcMax:IntLiteralWrapper
               |
               srcStar:"*" {
$$.srcMaxStar = TOK(srcStar);
}
            )
            ","
        )?
        // target, minimum
        (
        	min:IntLiteralWrapper
        	"." "."
        )?
        // target, maximum
        ( EXPECT ND UPON ( #INT_CONST# )
            max1:IntLiteralWrapper
            |
            star:"*" {
$$.maxStar = TOK(star);
}
        )
        {
RESOLVER.setCardinality($$.res,$srcMax.res,$$.srcMaxStar,$min.res,$max1.res,$$.maxStar);
}
    )
    "]"
;

////////////////////////////////////////////
// Composed identifiers in defining context
////////////////////////////////////////////

//this rule name is used in DdlErrorRecoveryHook
NamespacePath [IPathDeclaration path]:
    id_1 = IdWrapper
    {
RESOLVER.addEntry($$.path,RESOLVER.createPathEntry($id_1));
}
    (
        "."
        id_n = IdWrapper
        {
if (id_n != null) {
RESOLVER.addEntry($$.path,RESOLVER.createPathEntry($id_n.res));
}
}
    ) *
;

QualifiedDefId returns [IPathDeclaration res] // TODO: remove this rule (and AST structure)
:
    id_1 = IdWrapper
    {
$$.res = RESOLVER.createPathDeclaration();
RESOLVER.addEntry($$.res,RESOLVER.createPathEntry($id_1));
}
    (
        (
        )
        |
        (
            "."
            id_n = IdWrapper
            {
if ($id_n != null) {
RESOLVER.addEntry($$.res,RESOLVER.createPathEntry($id_n.res));
}
}
        ) *

        (
            "::"
            defid = DefId
            {
if ($defid != null) {
RESOLVER.addEntry($$.res,RESOLVER.createPathEntry($defid.res));
}
}
        )
    )
;

// Paris change start
QuotedId returns [Token res]:
    "\""
    id = #ID#
    {
var tok = TOK(id);
$$.res = tok;
}
    "\""
;
// Paris change end

IdWrapper returns [Token res]:
    (
	    id = #ID#
	    {
$$.res = TOK(id);
}
	)
	|
    (
        idq = QuotedId
        {
$$.res = $idq.res;
}
    )
;

/* Not taken, as the difference in the backend grammar is only inside the user defined actions. So we can use "IdWrapper" in the client's grammar
IdWrapperNoAutoQuote:
    (
        id = #ID#
    )
    |
    (
        q_id = QuotedId
    )
; */

/*			// the client scanner does not distinguish between "normal" identifiers and "pseudo" identifiers (starting with a "$" char)
PseudoIdWrapper returns [Token res] :
    (
        id = #PSEUDO_ID#
	    {
	       $$.res = TOK(id);
	    }
    )
;
*/

ScopedIdWrapper returns [Token res] :
	#COLON_FOLLOWED_BY_ID#
	id = IdWrapper
	{
$$.res = $id.res;
}
;


EnumIdWrapper returns [Token res]:
    id = #ENUM_ID#
    {
$$.res = TOK(id);
}
;

IntLiteralWrapper returns [Token res]:
    intLit = #INT_CONST#
    {
$$.res = TOK(intLit);
}
;

StringLiteralWrapper returns [Token res]:
    strLit = #STR_CONST#
    {
$$.res = TOK(strLit);
}
;

RealLiteral returns [Token res] :
    realLit = #REAL_CONST#
    {
$$.res = TOK(realLit);
}
;

BinaryLiteral returns [Token res] :
    binaryLit = #BINARY_CONST#
    {
$$.res = TOK(binaryLit);
}
;

DateLiteral returns [Token res] :
    dateLit = #DATE_CONST#
    {
$$.res = TOK(dateLit);
}
;

TimeLiteral returns [Token res] :
    timeLit = #TIME_CONST#
    {
$$.res = TOK(timeLit);
}
;

TimeStampLiteral returns [Token res] :
    timeStampLit = #TIMESTAMP_CONST#
    {
$$.res = TOK(timeStampLit);
}
;

NullLiteral returns [Token res] :
    nullLit = NULL
    {
$$.res = $nullLit.name;
}
;

////////////////////////////////////////////
// Identifier in defining context
////////////////////////////////////////////

DefId returns [Token res]:
    id1 = IdWrapper
    {
$$.res = $id1.res;
}
;


////////////////////////////////////////////
// Annotations
////////////////////////////////////////////


// take care of re-naming this rule name; its name is referenced in VersionsFactory#setErrorRecoveryHook
AnnotationValue [Object container]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
//  not needed in the frontend, as the EnumId is already handled by the AnnotationConstantId rule and the scanner
//  (
//      AnnotationEnumId
//  )
//  |
    (
    	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    	refToConst = PathSimple
    	{
$endIndex = RESOLVER.getLastMatchedTokenIndex();
var value = null;
var entries = $refToConst.res.getEntries();
if (entries.length == 1) {
var id = entries[ 0 ].getNameToken();
value = RESOLVER.addAnnotationValue($$.container,id);
}else if (entries.length >= 1) {
value = RESOLVER.addAnnotationPathValue($$.container,$refToConst.res);
}
if (value != null) {
RESOLVER.viewparser_setStartEndTokenIndex(value,$startIndex,$endIndex);
}
}
    )
    |
    (
    	{
$startIndex = RESOLVER.getNextTokenIndex();
}
        lit_val = AnnotationLiteral
        {
var av = RESOLVER.addAnnotationValue($$.container, $lit_val.res);
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex(av,$startIndex,$endIndex);
}
    )
    |
    (
        RecordValue[$$.container]
    )
    |
    (
        ArrayValue[$$.container]
    )

;

RecordValue
			[Object container]
returns		[IAnnotationRecordValue record]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    "{"
    {
$$.record = RESOLVER.createAnnotationRecordValue();
RESOLVER.addAnnotationRecordValue($$.container,$$.record);
}
    RecordComponent[$$.record]
    (
        ","
        RecordComponent[$$.record]
    ) *
    "}"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.record,$startIndex,$endIndex);
}
;

PreAnnotation
returns [IPreAnnotation res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    "@"
	{
$$.res = RESOLVER.createPreAnnotation();
}

    AnnotationPath[$$.res] //backend uses PathGeneric here
    (
        Colon
        AnnotationValue[$$.res]
    )?
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

RecordComponent
		[IAnnotationRecordValue container]
returns [IAnnotationNameValuePair res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
	{
$$.res = RESOLVER.createAnnotationNameValuePair();
RESOLVER.addAnnotationNameValuePair($$.container,$$.res);
}

	AnnotationPath[$$.res] //backend uses PathGeneric here
    (
    	Colon
    	AnnotationValue[$$.res]
    )?
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}

;

ArrayValue
		[Object container]
returns	[IAnnotationArrayValue array]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    "["
    {
$$.array = RESOLVER.createAnnotationArrayValue();
RESOLVER.addAnnotationArrayValue($$.container,$$.array);
}
    (
	    AnnotationValue[$$.array]
	    (
	        ","
	        AnnotationValue[$$.array]

	    ) *
	)?
    "]"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.array,$startIndex,$endIndex);
}
;

AnnotationPath //backend uses PathGeneric here
	[IAnnotationNameValuePair nameValuePair]
	:
    id_1 = AnnotationId
    {
RESOLVER.addAnnotationPath($$.nameValuePair,$id_1.res);
}
    (
        dot = "."
        {
RESOLVER.addAnnotationPath($$.nameValuePair,TOK(dot));
}
        id_n = AnnotationId
    	{
RESOLVER.addAnnotationPath($$.nameValuePair,$id_n.res);
}
    )*
;

// Annotation can contain any tokens, even reserved SQL keyword
//
// for example 'order' in
//  @Catalog.index:[ { name:'Index1', unique:false, order:#DESC, elementNames:['ELT1', 'ELT2' ] } ]
//
AnnotationId returns [Token res]:
    id = #ID# // runtime is using "UnreservedId" = matches #ID# and reserved keyword -> but desingtime is accepting everything -> intended behavior!!
    {
$$.res = TOK(id);
}
;

// not needed see above
//AnnotationEnumId:
//    id = #ENUM_ID#
//;

// backend direclty uses "Literal" here. But the client's "Literal" rule does not allow negative integers.
AnnotationLiteral returns [Token res]:
    (
        str_val = StringLiteralWrapper
        {
$$.res = $str_val;
}
    )
    |
    (
    	( %CCIGNORE "-" )?
        int_val = IntLiteralWrapper
        {
$$.res = $int_val;
}
    )
    |
    (
		( %CCIGNORE "-" )?
        real_lit = RealLiteral
        {
$$.res = $real_lit.res;
}
    )
    |
    (
        binary_lit = BinaryLiteral
        {
$$.res = $binary_lit.res;
}
    )
    |
    (
        date_lit = DateLiteral
        {
$$.res = $date_lit.res;
}
    )
    |
    (
        time_lit = TimeLiteral
        {
$$.res = $time_lit.res;
}
    )
    |
    (
        timestamp_lit = TimeStampLiteral
        {
$$.res = $timestamp_lit.res;
}
    )
// FIXME: NullLiteral NULL not yet supported in SemanticCheck
    |
    (
        null_lit = NullLiteral
        {
$$.res = $null_lit.res;
}
    )

;

//UnreservedIdWrapper rule not used at designtime;
//UnreservedId        rule not used at designtime; please use #ID# instead
//////////////////////////////////////////////////
// for the name of cds_named_value, we may use any tokens, even reserved SQL keyword
// UnreservedId may be used wherever all IDs are allowed

//QL: rule not taken because runtime colleagues are using it only for testing purposes of SELECT stmt (test and compare the ptime AST)
//Start_Condition not taken
//Start_Expression not taken

/******************************************************************************
 *
 * SELECT FROM <path> { <elementlist> } ...
 *
 ******************************************************************************/

QLSelectStmtNoOption [ISelectContainer parent]
:
	QLSubqueryComplex[$$.parent,null]
;

QLSubqueryWithParens [ISelectContainer parent,IViewSelectSet parentSelectSet]  returns [ISelect selectStmt]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    "("
	sq1 = QLSubqueryComplex[$$.parent,$$.parentSelectSet]
	{
$$.selectStmt = $sq1.selectStmt;
}
    ")"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.selectStmt,$startIndex,$endIndex);
}
;

QLSubqueryComplex [ISelectContainer parent,IViewSelectSet parentSelectSet]   returns [ISelect selectStmt]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    sq = QLSubquerySet[$$.parent,$$.parentSelectSet]
    {
$$.selectStmt = $sq.select;
}
    OrderByClause[$$.selectStmt]
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.selectStmt,$startIndex,$endIndex);
}
;

QLSubquerySet [ISelectContainer parent,IViewSelectSet parentSelectSet]  returns [ISelect select]
	@init{
		int startIndex = 0;
		int endIndex = 0;
		IViewSelectSet tempSelectSet = null;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
	(
		(
			sq1a = QLSubqueryElementary[$$.parent,$$.parentSelectSet]
			{
$$.select = $sq1a.selectStmt;
}
		)
		|
		(
			sq1b = QLSubqueryWithParens[$$.parent,$$.parentSelectSet]
			{
$$.select = $sq1b.selectStmt;
}
		)
	)
	(
		set = SetOperator
		(
			(
				{
$tempSelectSet = RESOLVER.createViewSelectSet($set.operator,$set.all,$set.distinct,$$.select,null);
if ($$.select != null) {
var leftStartIndex = $$.select.getStartTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($tempSelectSet,leftStartIndex,-1);
}
if (parent != null) {
parent.setSelectSet($tempSelectSet);
}
if ($$.parentSelectSet != null) {
$$.parentSelectSet.setRight($tempSelectSet);
$$.parentSelectSet = null;
}
}
				sq2a = QLSubqueryElementary[null,$tempSelectSet]
				{
$$.select = $tempSelectSet;
}
			)
			|
			(
				{
$tempSelectSet = RESOLVER.createViewSelectSet($set.operator,$set.all,$set.distinct,$$.select,null);
if ($$.select != null) {
var leftStartIndex = $$.select.getStartTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($tempSelectSet,leftStartIndex,-1);
}
if (parent != null) {
parent.setSelectSet($tempSelectSet);
}
if ($$.parentSelectSet != null) {
$$.parentSelectSet.setRight($tempSelectSet);
$$.parentSelectSet = null;
}
}
				sq2b = QLSubqueryWithParens[null,$tempSelectSet]
				{
$$.select = $tempSelectSet;
}
			)
		)
		{
if (parent != null) {
parent.setSelectSet($select);
}
}
	    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.select,$startIndex,$endIndex);
}
	)*
;


QLSubqueryElementary [ISelectContainer parent,IViewSelectSet parentSelectSet] returns [IViewSelect selectStmt]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    SELECT
    {
$$.selectStmt = RESOLVER.viewparser_startSelect();
if ($$.parent != null) {
$$.parent.setSelect($$.selectStmt);
}
if ($$.parentSelectSet != null) {
$$.parentSelectSet.setRight($$.selectStmt);
}
RESOLVER.viewparser_setStartEndTokenIndex($$.selectStmt,$startIndex,-1);
}
    from = FromClause[$$.selectStmt]
	adhoc = AdhocDeclarationBlock[$$.selectStmt]
    select = QLSelectClause[$$.selectStmt, null]
    where = WhereClause[$$.selectStmt]
    group = GroupByClause[$$.selectStmt]
    having = HavingClause[$$.selectStmt]
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.selectStmt,$startIndex,$endIndex);
}
;

AdhocDeclarationBlock [IViewSelect select] :
    (
        "mixin" "{"
        (
            elem = AdhocElementDeclaration[$$.select]
        )*
        "}" "into"
    )?
;

AdhocElementDeclaration [IViewSelect select]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
    "element"?
    id = DefId
    //type = TypeSpec[null, null]  // backend simply uses TypeSpec, but this is too broad. It's only allowed to define associations here. We simply use "Colon AssociationTo" here.
    Colon
    {
$startIndex = RESOLVER.getNextTokenIndex();
}
    assocTo = AssociationTo[null,null,$$.select]
    {
$assocTo.res.setNameToken($id.res);
$assocTo.res.setNamePath(null);
RESOLVER.viewparser_setStartTokenIndex($assocTo,$startIndex);
}
    AssociationOnCondition[$assocTo.res]
    ";"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($assocTo,$startIndex,$endIndex);
}
    %COMMIT
;

QLSelectClause [IViewSelect select,ISelectList list] returns [ISelectList res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
	"{"
 	(
		{
if ($$.list != null) {
$$.res = $$.list;
}else{
$$.res = RESOLVER.viewparser_startSelectList0();
RESOLVER.viewparser_selectlist($$.select,$$.res);
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,-1);
}
}
	   	QLSelectList[res]
   	)?
 	"}"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

QLSelectList [ISelectList list] :

	AnnotatedQLSelectItem[list]
	(
		","
		%COMMIT  // do a commit for performance reasons after each select list entry
		p2=AnnotatedQLSelectItem[list]
	)*
;

//this rule name is used in DdlErrorRecoveryHook
AnnotatedQLSelectItem [ISelectList list] returns [List<IPreAnnotation> preAnnotations]
    :

    {
$$.preAnnotations = RESOLVER.createPreAnnotationList();
}
    (
        annotation = PreAnnotation
        {
RESOLVER.collectPreAnnotation($$.preAnnotations,$annotation.res);
}
    ) *

    QLSelectItem[$$.preAnnotations,$$.list]
;

QLSelectItem [List<IPreAnnotation> preAnnotations,ISelectList list] returns [ISelectListEntry res]:
    p1 = ExprSelectItem[$$.preAnnotations,$$.list]
    {
$$.res = $p1.entry;
}
    |
    p2 = QLPathListSelectItem[$$.preAnnotations,$$.list]
    {
$$.res = $p2.entry;
}
;

QLPathListSelectItemAlias [ISelectListEntry entry] // this rule exists only on client. It was introduced for better code completion support; don't propose entity/view elements for alias id.
:
 	(
    	(AS)?
        alias1 = IdWrapper
        {
if ($$.entry != null) {
RESOLVER.viewparser_alias($$.entry,alias1.res);
}
}
	)
;


QLPathListSelectItem [List<IPreAnnotation> preAnnotations,ISelectList list] returns [ISelectListEntry entry]  // AM: Does the return val really need a NULL default? I don't think so.
	@init{
		INestedSelectListPathEntry nestedEntry = null;
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
	(
		(
			pathExp = QLPath
			{
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex(pathExp.res,$startIndex,$endIndex);
}
			{
$$.entry = RESOLVER.viewparser_selectListEntry($pathExp.res);
RESOLVER.addAnnotations($$.entry,$$.preAnnotations);
RESOLVER.viewparser_addSelectListEntry($$.list,$$.entry);
}
			QLPathListSelectItemAlias[$$.entry]?
			(
				{
var nestedList = IAstFactory.eINSTANCE.createSelectList();
$nestedEntry = IAstFactory.eINSTANCE.createNestedSelectListPathEntry();
nestedEntry.setSelectList(nestedList);
$pathExp.res.getPathEntries().push($nestedEntry);
}
				%CCIGNORE p2 = QLSelectClause[null,$nestedEntry.getSelectList()]
			)
		)
		|
		(
			{
var nestedList = IAstFactory.eINSTANCE.createSelectList();
$nestedEntry = IAstFactory.eINSTANCE.createNestedSelectListPathEntry();
nestedEntry.setSelectList(nestedList);
var pExp = RESOLVER.createPathExpression();
pExp.getPathEntries().push($nestedEntry);
$$.entry = RESOLVER.viewparser_selectListEntry(pExp);
RESOLVER.addAnnotations($$.entry,$$.preAnnotations);
RESOLVER.viewparser_addSelectListEntry($$.list,$$.entry);
}
			%CCIGNORE p3 = QLSelectClause[null,$nestedEntry.getSelectList()]
			QLPathListSelectItemAlias[$$.entry]?
		)
	)

	{
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.entry,$startIndex,$endIndex);
}
;

QLPath returns [IPathExpression res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$$.res = RESOLVER.createPathExpression();
$startIndex = RESOLVER.getNextTokenIndex();
RESOLVER.viewparser_setStartTokenIndex($$.res,$startIndex);
}
	(
		(
			id1=IdWrapper
			{
RESOLVER.addEntry($$.res,RESOLVER.createPathEntry($id1.res));
}
			|
/*			idps1=PseudoIdWrapper
			{
				addEntry($$.res,createPathEntry($idps1.res));
			}
			|*/
			idsc1=ScopedIdWrapper
			{
RESOLVER.addEntry($$.res,RESOLVER.createPathEntry($idsc1.res));
}
		)
	)
	(
		"."
		id2=IdWrapper
		{
RESOLVER.addEntry($$.res,RESOLVER.createPathEntry($id2.res));
}
	)*
	{
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

//this rule name is used in DdlErrorRecoveryHook
PathGeneric [IPathExpression path] :
    id1=IdWrapper
    {
RESOLVER.addEntry($$.path,RESOLVER.createPathEntry($id1.res));
}
    (   "."  id2=IdWrapper
        {
RESOLVER.addEntry($$.path,RESOLVER.createPathEntry($id2.res));
}
    )*
;

PathSimple returns [IPathExpression res] :
	{
$$.res = RESOLVER.createPathExpression();
}
	path=PathGeneric[res]
;

PathWithNamespace returns[ IPathExpression res] :
	{
$$.res = RESOLVER.createPathExpression();
}
    NamespacePath[res]
    {
RESOLVER.markLastNamespacePathEntry($$.res);
}
    "::"
    PathGeneric[res]
;

PathWithAlias returns [IPathExpression res, Token alias] :
    path = PathSimple
    {
$$.res = $path.res;
}
    (
        AS alias = IdWrapper
        {
$$.alias = $alias.res;
}
    )?
;

SetOperator returns [Token operator, Token all, Token distinct]
:
	(
		union:"union" {
$$.operator = TOK(union);
}
      	(
      		( all:"all" {
$$.all = TOK(all);
} )
      		|
      		( dist:"distinct" {
$$.distinct = TOK(dist);
} )?
      	)
    )
    |
    (
    	int1:"intersect" {
$$.operator = TOK(int1);
}
    	(
    		dist1:"distinct"{
$$.distinct = TOK(dist1);
}
    	)?
    )
    |
    (
    	exc:"except" {
$$.operator = TOK(exc);
}
    	(
    		dist2:"distinct"{
$$.distinct = TOK(dist2);
}
    	)?
    )
    |
    (
    	minus:"minus" {
$$.operator = TOK(minus);
}
    	(
    		dist3:"distinct"{
$$.distinct = TOK(dist3);
}
    	)?
    )
;

ExprSelectItem [List<IPreAnnotation> preAnnotations,ISelectList list] returns [ISelectListEntry entry]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    alias = ExprAlias
    {
$$.entry = RESOLVER.viewparser_selectListEntry($alias.res);
RESOLVER.addAnnotations($$.entry,$$.preAnnotations);
RESOLVER.viewparser_addSelectListEntry($$.list,$$.entry);
RESOLVER.viewparser_alias($$.entry,$alias.alias);
}

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.entry,$startIndex,$endIndex);
}
;

FromClause [IViewSelect select] returns [IDataSource res] :
    FROM
    // allow empty FROM clause in order to produce precise error message in semantic check
    (
    	l:TablePathList
    	{
if ($$.select != null) {
$$.res = $l.res;
$$.select.setFrom($$.res);
}
}
    ) //? we don't allow empty from clause in the client grammar, error recovery will not work if this is optional
;

TablePathList returns [IDataSource res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    tab_path_1 = TablePath
    {
$$.res = $tab_path_1.res;
}

    //after discussion with Steffen Weinstock
    // define view v as select from table1, table2, .... where table1.id = table2.id
    // this is the old way how to define an inner join; on condition is then specified in the where clause
    // we will not support this kind of statement
    /*
    (
        ","
        tab_path_n = TablePath
        {
            $$.res = viewparser_innerjoinDatasource($$.res,$tab_path_n.res,null);
        }
    ) *
    */

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

TablePathAlias returns [Token res] :
	(
        (AS)?
        alias = IdWrapper
        {
$$.res = $alias.res;
}
    )?
;

TablePath  returns [IDataSource res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    path = QLPath
    // backend also allowed PathWithNamespace as alternative to QLPath. But this is only for "AdHoc-QL" (e.g. in the SQL console). For DDL it's inhibited in a semantic check. Therefore not relevant for the frontend grammar.

	alias = TablePathAlias

    {
$$.res = RESOLVER.viewparser_tableDatasource($path.res);
if ($alias.res != null) {
$$.res.setAliasToken($alias.res);
}
}

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

WhereClause [IViewSelect select] returns [IExpressionContainer res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    (
        WHERE
        cond = Condition
        {
$$.res = RESOLVER.createExpressionContainer($cond.res);
if ($$.select != null) {
$$.select.setWhere($$.res);
}
}
    )?
    {
if ($$.res != null) {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
}
;

/* Note: For now, we don't support the more complex forms of GROUP: grouping_sets, rollup_expression, cube_expression */
GroupByClause [IViewSelect select] returns [IGroupBy res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
    {
$startIndex = RESOLVER.getNextTokenIndex();
}
    (
        GROUP BY
        (
            list:ExpressionList
            {
var groupBy = RESOLVER.viewparser_groupBy1($list.res);
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex(groupBy,$startIndex,$endIndex);
select.setGroupBy(groupBy);
}
        )
    )?
;

HavingClause [IViewSelect select] returns [IExpressionContainer res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
    (
    	{
$startIndex = RESOLVER.getNextTokenIndex();
}
        HAVING
        cond = Condition
        {
var cont = RESOLVER.createExpressionContainer($cond.res);
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex(cont,$startIndex,$endIndex);
select.setHaving(cont);
}
    )?
;

OrderByClause [ISelect select]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
    (
    	{
$startIndex = RESOLVER.getNextTokenIndex();
}
        ORDER
        {
RESOLVER.viewparser_setEndTokenIndex($$.select,-1);
}
        BY
        order = SortSpecList
        {
var orderBy = RESOLVER.viewparser_createOrderBy($order.res);
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex(orderBy,$startIndex,$endIndex);
if ($$.select != null) {
$$.select.setOrderBy(orderBy);
RESOLVER.viewparser_setEndTokenIndex($$.select,$endIndex);
}
}
    )?
;

SortSpecList returns[List<IOrderByEntry> res]:
    spec1 = SortSpec
    {
$$.res = [];
$$.res.push($spec1.res);
}
    (
        "," specN = SortSpec
        {
$$.res.push($specN.res);
}
    )*
;

SortSpec returns[IOrderByEntry res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    expr = Expression
    order = OptAscDesc
    nfl = OptNullsFirstLast
    {
$$.res = RESOLVER.viewparser_createOrderByEntry($expr.res);
$$.res.setOrderSequenceToken($order.res);
$$.res.setNullsToken(nfl.nulls);
$$.res.setNullsFirstLastToken(nfl.firstLast);
}

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

OptAscDesc returns [Token res] :
    () /* empty */
    |
    asc:ASC
    {
$$.res = $asc.name;
}
    |
    des:DESC
    {
$$.res = $des.name;
}
;

OptNullsFirstLast returns [Token nulls,Token firstLast]:
    () /* empty */
    |
	(
	    n:NULLS
	    (
	        f:FIRST
	        {
$$.nulls = $n.name;
$$.firstLast = $f.name;
}
	        |
	        l:LAST
	        {
$$.nulls = $n.name;
$$.firstLast = $l.name;
}
	    )
	)
;

Condition returns [IExpression res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    condAnd = ConditionAnd
    {
$$.res = $condAnd.res;
}
    (
        OR
        right = ConditionAnd
        {
if ($$.res == null) {
$$.res = RESOLVER.viewparser_orExpression($condAnd.res,$right.res);
}else $$.res = RESOLVER.viewparser_orExpression($$.res,$right.res);
}
    )*

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

ConditionAnd returns [IExpression res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    condTerm = ConditionTerm
    {
$$.res = $condTerm.res;
}
    (
        AND
        right = ConditionTerm
        {
$$.res = RESOLVER.viewparser_andExpression($$.res,$right.res);
}
    )*

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

ConditionTerm returns [IExpression res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
	(
	    (
	        NOT
	        cond1 = ConditionTerm
	        {
$$.res = RESOLVER.viewparser_notExpression($cond1.res);
}
	    )
	    |
	    (
	        "("
	        cond2 = Condition
	        {
$$.res = $cond2.res;
}
	        ")"
	    )
	    |
	    (
	        predLeftIsExpr = PredicateLeftIsExpression
	        {
$$.res = $predLeftIsExpr.res;
}
	    )
    )

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

PredicateLeftIsExpression returns [IExpression res,boolean negated=false]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
    {
$startIndex = RESOLVER.getNextTokenIndex();
}
    (
    	left = Expression
    	|
    	AspectExpression
    )
    (
        (
            comp = ComparisonPredicate[$left.res]
            {
$$.res = $comp.res;
}
        )
        |
        (
            nullPred = NullPredicate[$left.res]
            {
$$.res = $nullPred.res;
}
        )
        |
        (
            ( NOT {
$$.negated = true;
} )?
            (
                (
                    range = RangePredicate[$left.res, negated]
                    {
if ($$.negated == true) {
$$.res = RESOLVER.viewparser_notExpression($range.res);
}else{
$$.res = $range.res;
}
}
                )
                |
                (
                    like = LikePredicate[$left.res, negated]
                    {
if ($$.negated == true) {
$$.res = RESOLVER.viewparser_notExpression($like.res);
}else{
$$.res = $like.res;
}
}
                )
                |
                (
                    in = InPredicate[$left.res, negated]
                    {
if ($$.negated == true) {
$$.res = RESOLVER.viewparser_notExpression($in.res);
}else{
$$.res = $in.res;
}
}
                )
            )
        )
    )

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

ComparisonPredicate [IExpression left] returns [IExpression res,Token comp]:
    (
        eq:"="
        {
$$.comp = TOK(eq);
}
    |
        gs:"<>"
        {
$$.comp = TOK(gs);
}
    |
        b:">"
        {
$$.comp = TOK(b);
}
    |
        be:">="
        {
$$.comp = TOK(be);
}
    |
        s:"<"
        {
$$.comp = TOK(s);
}
    |
        se:"<="
        {
$$.comp = TOK(se);
}
    )
    (
    	right = Expression
    	|
    	AspectExpression
    )
    {
$$.res = RESOLVER.viewparser_compExpression($$.comp,$$.left,$right.res);
}
;

RangePredicate [IExpression expr1, boolean negated] returns [IExpression res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
    {
$startIndex = RESOLVER.getNextTokenIndex();
}
    BETWEEN
    expr2 = Expression
    (
	    AND
	    expr3 = Expression
	    {
$$.res = RESOLVER.viewparser_betweenExpression($$.expr1,$expr2.res,$expr3.res);
}
    )
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

LikePredicate [IExpression expr1, boolean negated] returns [IExpression res,Token escapeToken]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    l = LIKE
    (
    	expr2 = Expression
    	|
    	AspectExpression
    )
    (
        ESCAPE
        expr3 = Expression
        {
$$.escapeToken = ($expr3.res).getTokenToken();
}
    )?
    {
$$.res = RESOLVER.viewparser_likeExpression($l.name,$$.expr1,$expr2.res,$$.escapeToken);
}

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

NullPredicate [IExpression expr] returns [IExpression res,boolean isNull=false]:
    IS
    (
        NOT
        {
$$.isNull = true;
}
    )?
    NULL
    {
$$.res = RESOLVER.viewparser_nullExpression($$.expr,$$.isNull);
}
;

//This rulename is used in code completion logic. Consider this when you change.
InPredicate [IExpression left, boolean negated] returns [IExpression res]
	@init{
		IInExpression inExpression = null;
	}
:
    IN
    (
    	(
		    "("
		    list:ExpressionList
		    ")"
		    {
$$.res = RESOLVER.viewparser_inExpression($$.left,$list.res);
}
		)
		|
		(
			{
$inExpression = IAstFactory.eINSTANCE.createInExpression();
$$.res = $inExpression;
$inExpression.setLeft($$.left);
}
			(
				(
					expr:Expression
				    {
$inExpression.getIns().push($expr.res);
}
			    )
				|
				AspectExpression
			)
		)
	)
;

ExpressionList returns [List<IExpression> res] :
    expr = Expression
    {
$$.res = [];
$$.res.push($expr.res);
}
    (
        ","
        expr_n = Expression
        {
$$.res.push($expr_n.res);
}
    )*
;


Expression returns [IExpression res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
    // still lacking CASE stuff, so just delegating
    {
$startIndex = RESOLVER.getNextTokenIndex();
}
    exprConcat = ExprConcat
    {
$$.res = $exprConcat.res;
}

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

ExprConcat returns [IExpression res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    exprSum1 = ExprSum
    {
$$.res = $exprSum1.res;
}
    (
        op:#PIPE_PIPE# exprSum2 = ExprSum
        {
$$.res = RESOLVER.viewparser_createConcatenationExpression($$.res,$exprSum2.res,TOK(op));
}
    )*

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

ExprSum returns [IExpression res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    exprFactor1 = ExprFactor
    {
$$.res = $exprFactor1.res;
}
    (
        (
            opPlus:"+" exprFactor2 = ExprFactor
            {
$$.res = RESOLVER.viewparser_createConcatenationExpression($$.res,$exprFactor2.res,TOK(opPlus));
}
        )
        |
        (
            opMinus:"-" exprFactor3 = ExprFactor
            {
$$.res = RESOLVER.viewparser_createConcatenationExpression($$.res,$exprFactor3.res,TOK(opMinus));
}
        )
    )*

    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

ExprFactor returns [IExpression res]:
    exprTerm1 = ExprTerm
    {
$$.res = $exprTerm1.res;
}
    (
        (
            opMul:"*" exprTerm2 = ExprTerm
            {
$$.res = RESOLVER.viewparser_createConcatenationExpression($$.res,$exprTerm2.res,TOK(opMul));
}
        )
        |
        (
            opDiv:"/" exprTerm3 = ExprTerm
            {
$$.res = RESOLVER.viewparser_createConcatenationExpression($$.res,$exprTerm3.res,TOK(opDiv));
}
        )
    )*
;


ExprTerm returns [IExpression res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
	(
	    (
	        col = QLPath
	        {
$$.res = $col.res;
}
	    )
	    |
	    (
	        opPlus:"+" exprTerm1 = ExprTerm
	        {
$$.res = RESOLVER.viewparser_createConcatenationExpression(null,$exprTerm1.res,TOK(opPlus));
}
	    )
	    |
	    (
	        opMinus:"-" exprTerm2 = ExprTerm
	        {
$$.res = RESOLVER.viewparser_createConcatenationExpression(null,$exprTerm2.res,TOK(opMinus));
}
	    )
	    |
	    (
	        "(" exprTerm3 = Expression ")"
	        {
$$.res = $exprTerm3.res;
}
	    )
	    |
	    (
	        literal = Literal
	        {
$$.res = RESOLVER.viewparser_iliteral($literal.res);
}
	    )
	    |
	    (
	        agg = Agg
	        {
$$.res = $agg.res;
}
	    )
	    |
	    (
	        func = Func
	        {
$$.res = $func.res;
}
	    )
	    |
	    (
	    	namedArgFunc = NamedArgFunc
	        {
$$.res = $namedArgFunc.res;
}
	    )
		|
	    (
	    	caseExpr = CaseExpression
	        {
$$.res = $caseExpr.res;
}
	    )
    )
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

AspectExpression
:
    (
    	"aspect"
    	QLPathStartRule
    )
;

// this rule is made as startRule for error recovery. This rule is not called as start rule from parser. RND_TOOL generates vm program counter index for beginning of rule when option startRule is set. This PC index is needed for the error recovery logic (see BaseCdsDdlParser#recoverToStartOfRule)
QLPathStartRule
options{
	startrule = "TRUE";
}
:
	QLPath
;


CaseExpression returns [IExpression res ]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    "case"
    (
        (
        	// simple case
            expr1    = Expression
            {
$$.res = RESOLVER.createSimpleCaseExpression($expr1.res);
}
            cases1   = WhenExpressionThenList[$$.res]
        )
        |
        (
        	// searched case
			{
$$.res = RESOLVER.createSearchedCaseExpression();
}
            cases2   = WhenConditionThenList[$$.res]
        )
    )
    (
        "else"
        optElse = Expression
		{
RESOLVER.addElseExpression($$.res,$optElse.res);
}
    )?
    "end"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

WhenExpressionThenList[IExpression caseExpr]:
    listEl1 = WhenExpressionThen[$$.caseExpr]
    (
        listEl2 = WhenExpressionThen[$$.caseExpr]
    )*
;

WhenConditionThenList[IExpression caseExpr] :
    listEl1 = WhenConditionThen[$$.caseExpr]
    (
        listEl2 = WhenConditionThen[$$.caseExpr]
    )*
;

WhenExpressionThen[IExpression caseExpr]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    "when"
    expr1 = Expression
    "then"
    expr2 = Expression
    {
var caseWhen = RESOLVER.addAndReturnNewCaseWhenExpression( $$.caseExpr, $expr1.res, $expr2.res);
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex(caseWhen,$startIndex,$endIndex);
}
;

WhenConditionThen[IExpression caseExpr]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    "when"
    cond1 = Condition
    "then"
    expr1 = Expression
    {
var caseWhen = RESOLVER.addAndReturnNewCaseWhenExpression( $$.caseExpr, $cond1.res, $expr1.res);
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex(caseWhen,$startIndex,$endIndex);
}
;

Literal returns [Token res] :
    (
        int_val = IntLiteralWrapper
        {
$$.res = $int_val.res;
}
    )
    |
    (
        string_lit = StringLiteralWrapper
        {
$$.res = $string_lit.res;
}
    )
    |
    (
        real_lit = RealLiteral
        {
$$.res = $real_lit.res;
}
    )
    |
    (
        binary_lit = BinaryLiteral
        {
$$.res = $binary_lit.res;
}
    )
    |
    (
        date_lit = DateLiteral
        {
$$.res = $date_lit.res;
}
    )
    |
    (
        time_lit = TimeLiteral
        {
$$.res = $time_lit.res;
}
    )
    |
    (
        timestamp_lit = TimeStampLiteral
        {
$$.res = $timestamp_lit.res;
}
    )
// FIXME: NullLiteral NULL not yet supported in SemanticCheck
    |
    (
        null_lit = NullLiteral
        {
$$.res = $null_lit.res;
}
    )
;

// FIXME: Shouldn't we also take care of "AS" and res->alias here?
ExprAlias returns [IExpression res,Token alias] :
    expr = Expression
    {
$$.res = $expr.res;
}
    (
        (AS)?
        alias1 = IdWrapper
        {
$$.alias = $alias1.res;
}
    )?
;


// Aggregate function
Agg returns [IExpression res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
    {
$startIndex = RESOLVER.getNextTokenIndex();
}
    agg_name = AggName
    "("
    (
        (
	        st:'*'
	        {
$$.res = RESOLVER.viewparser_stdFunctionExpression($agg_name.res,RESOLVER.viewparser_iliteral(TOK(st)));
}
	    )
        |
        (
        	agg_all = OptAll
        	agg_expr = Expression
	        {
$$.res = RESOLVER.viewparser_stdFunctionExpression($agg_name.res,$agg_expr.res);
($$.res).setAllToken($agg_all.res);
}
        )
        |
        (
        	d:DISTINCT
        	agg_expr2 = Expression
	        {
$$.res = RESOLVER.viewparser_stdFunctionExpression($agg_name.res,$agg_expr2.res);
($$.res).setDistinctToken($d.name);
}
		)
    )
    ")"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

AggName returns [Token res]:
    c:COUNT      {
$$.res = $c.name;
}
    | mi:MIN     {
$$.res = $mi.name;
}
    | ma:MAX     {
$$.res = $ma.name;
}
    | su:SUM     {
$$.res = $su.name;
}
    | av:AVG     {
$$.res = $av.name;
}
    | std:STDDEV {
$$.res = $std.name;
}
    | va:VAR     {
$$.res = $va.name;
}
;

OptAll returns [Token res]:
    () /* empty */ {
$$.res = null;
}
    | a:ALL        {
$$.res = $a.name;
}
;

// Built-in function with named argument
NamedArgFunc returns[IFuncWithNamedParamExpression res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    func_name = NamedArgumentFuncName
    {
$$.res = RESOLVER.viewparser_funcWithNamedParamExpression($func_name.res);
}
    "("
    (
        expr = NamedArgument[$$.res]
        (
            "," NamedArgumentList[$$.res]
        )?
    )?
    ")"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

NamedArgument[IFuncWithNamedParamExpression funcExpr]
	@init{
		int startIndex = 0;
		int endIndex = 0;
		IFuncParam funcParam = null;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    proc_param_name = IdWrapper
    {
$funcParam = RESOLVER.viewparser_addFuncParam($$.funcExpr,$proc_param_name.res);
}
    "=>"
    expr1 = Expression
    {
$funcParam.setExpression($expr1.res);
}
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($funcParam,$startIndex,$endIndex);
}
;

NamedArgumentList[IFuncWithNamedParamExpression funcExpr]
:
    expr = NamedArgument[funcExpr]
    (
        ","
        expr_n = NamedArgument[funcExpr]
    )*
;

// Built-in function
Func returns [IFuncExpression res]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}
    func_name = FuncName
    "("
    {
$$.res = RESOLVER.viewparser_funcExpression($func_name.res);
}
    (
        expr = Expression
        {
RESOLVER.viewparser_addFuncExprParameter($$.res,$expr.res);
}
        (
            "," list:ExpressionList
            {
for (var exCount = 0;exCount < list.length;exCount++) {
var ex = list[exCount];
RESOLVER.viewparser_addFuncExprParameter($$.res,ex);
}
}
        )?
    )?
    ")"
    {
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.res,$startIndex,$endIndex);
}
;

NamedArgumentFuncName returns [Token res]:
    (
        id1 = "convert_currency" {
$$.res = TOK(id1);
}
    |
        id2 = "convert_unit" {
$$.res = TOK(id2);
}
    )
;

// Name of simple function that looks like ordinary functions do: FOO(params)
FuncName returns [Token res]:
 // The extremely simple ones where Function name matches QPC_FUNC enum, with args
(
      "abs"
    | "acos"
    | "add_days"
    | "add_months"
    | "add_seconds"
    | "add_years"
    | "ascii"
    | "asin"
    | "atan"
    | "atan2"
// These functions are not documented anywhere, so we do not support them (yet?)
//  | "bind_bigint"
//  | "bind_char"
//  | "bind_decimal"
//  | "bind_double"
//  | "bind_nchar"
//  | "bind_real"
    | "bintohex"
    | "bitand"
    | "ceil"
    | "coalesce"
    | "concat"
    | "cos"
    | "cosh"
    | "cot"
    | "days_between"
    | "exp"
    | "floor"
    | "greatest"
    | "hasanyprivileges"
    | "hassystemprivilege"
    | "hextobin"
    | "ifnull"
    | "isauthorized"
    | "last_day"
    | "least"
    | "length"
    | "ln"
    | "locate"
    | "log"
    | "lower"
    | "lpad"
// This function is internally implemented as a CASE statement (see ptime::qo_Func::toExpression)
// We don't support that yet
//  | "map"
    | "mod"
    | "next_day"
    | "nullif"
    | "power"
    | "replace"
    | "round"
    | "rpad"
    | "seconds_between"
    | "session_context"
    | "sign"
    | "sin"
    | "sinh"
    | "sqrt"
    | "substr"
    | "substr_after"
    | "substr_before"
    | "tan"
    | "tanh"
    | "to_bigint"
    | "to_binary"
    | "to_blob"
    | "to_char"
    | "to_clob"
    | "to_date"
    | "to_dats"
    | "to_decimal"
    | "to_double"
    | "to_int"
    | "to_integer"
    | "to_nchar"
    | "to_nclob"
    | "to_nvarchar"
    | "to_real"
    | "to_seconddate"
    | "to_smalldecimal"
    | "to_smallint"
    | "to_time"
    | "to_timestamp"
    | "to_tinyint"
    | "to_varbinary"
    | "to_varchar"
    | "unicode"
    | "upper"
    | "weekday"
 // The ones where the function name does not match QPC_FUNC code, with args
    | "char"
 // This function is related to grouping sets, which are not supported yet
 // | "grouping"
    | "nchar"
 // The ones where the function is actually an alias of another function, with args
    | "instr"
    | "lcase"
    | "substring"
    | "ucase"
 // The ones where the function name does match QPC_FUNC code, no args
 // This function is related to grouping sets, which are not supported yet
 // | "grouping_filter"
 // This function is not documented anywhere, so we do not support it (yet?)
 // | "istotal"
 // The ones where the function name does match QPC_FUNC code, no args
    | "curdate"
    | "curtime"
    | "database"
    | "now"
 // This function is not documentres = QPC_FUNC_ACOS;ed anywhere, so we do not support it (yet?)
 // | "olymp"
    | "user"
)
{
$$.res = TOK_AT(this.getFirstTokenIndex());
}
;

////////////////////////////////////////
// Annotation Definitions (only client)
//
// TODO: typeSpec, enumClause and defaultClause are now defined two times in the grammar.
//  Please fix this flaw when runtime colleagues also introduced annotationDefinitions in their grammar.
//
////////////////////////////////////////

DDL_ENUM      : 'enum' ;
DDL_COLON     : ":";

/* This rule is used to parse the Annotations that can be used in DDL Sources
   Currently this is not possible for the user to define his own annotations  */
annotationDefintions
options{
	startrule = "TRUE";
}
:
	defs=annotationDefintionsWithAnnotation[null]
;

annotationDefintionsWithAnnotation
[List<IPreAnnotation> preAnnotations]
:
	{
RESOLVER.compilationUnit = IAstFactory.eINSTANCE.createCompilationUnit();
}
	(
		{
$$.preAnnotations = RESOLVER.createPreAnnotationList();
}
		(
			annotation = PreAnnotation
			{
RESOLVER.collectPreAnnotation($$.preAnnotations,$annotation.res);
}
		)*
		definition = AnnotationDeclaration[null,null]
 		{
if ($definition != null && $$.preAnnotations != null) {
RESOLVER.addAnnotations($definition.anno,$$.preAnnotations);
}
}
	)*
;

AnnotationDeclaration
		[List<IPreAnnotation> annots,List<IDdlStatement> parentStmts]
returns [IAnnotationDeclaration anno]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	{
$startIndex = RESOLVER.getNextTokenIndex();
}

	"annotation"
	name=QualifiedDefId
	{
$$.anno = RESOLVER.createAnnotationDeclarationWithPath($name.res);
if ($$.annots != null) {
RESOLVER.addAnnotations($$.anno,$$.annots);
}
if ($$.parentStmts != null) {
$$.parentStmts.push($$.anno);
}else{
RESOLVER.viewparser_setDDLStmt($$.anno);
}
RESOLVER.viewparser_setStartEndTokenIndex($$.anno,$startIndex,-1);
}
	type = annotationTypeSpec[$$.anno]

   	(
   		";"
   	)?
   	{
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.anno,$startIndex,$endIndex);
}
   	 %COMMIT
;

arrayCardinality[IElementDeclaration element]:
	start:"["
	(
		//min
        min:IntLiteralWrapper
    	"." "." //TODO replace with one ".." token
    	//max
        (
            max1:IntLiteralWrapper
            |
            max2:"*"
        )
	)?
	end:"]"
	{
if ($$.element != null) {
var max = null;
if ($max1 != null) {
max = $max1.res;
}else{
max = TOK(max2);
}
RESOLVER.setArrayCardinality($$.element,TOK(start),$min.res,max,TOK(end));
}
}
;

annotationTypeSpec
[IElementDeclaration element]
:
	(
		DDL_COLON
		(
			AnnotationTypeArray[$$.element]
			|
			AnnotationTypeNamedOrEnum[$$.element]
			|
			AnnotationTypeTypeOf[$$.element]
		)
	)
	|
	(
		type2 = annotationStructuredType[$$.element, null]
	)
;

AnnotationTypeTypeOf
[IElementDeclaration element]
:
    TYPE OF id = PathSimple
    {
$$.element.setTypeOfPath($id);
}
;

AnnotationTypeNamedOrEnum
[IElementDeclaration element]
:

	AnnotationTypeNamed[$$.element]
	(
		enumeration = annotationEnumClause[$$.element, null]
	)?
	(
		def = AnnotationDefaultClause[$$.element]  //backend does not allow default yet, but we allow it on the client to be able to provide defaults in Annotation Code completion
	)?
	";" %COMMIT
;

// the only reason for copy-ing this rule is the %CCIGNORE. Delete this rule, once Annotations "officially" support the definition of Default Values.
AnnotationDefaultClause [IElementDeclaration res] :
    (
    	%CCIGNORE DEFAULT
        (
	        (
		        expr = Expression
		        {
RESOLVER.viewparser_setElementDefault($$.res,$expr.res);
}
			)
	        |
	        (
	        	enumVal = EnumIdWrapper //Christoph W.: EnumId should be handled inside Expressions later on. If this changes, we have to change the error recovery accordingly.
	        	{
RESOLVER.viewparser_setElementDefaultToken($$.res,$enumVal.res);
}
	        )
        )
    )
;

AnnotationTypeNamed
[IElementDeclaration element]
:
	typeName=AnnotationTypeName
	{
$$.element.setTypeIdPath($typeName);
}
	(
		"("
		length:IntLiteralWrapper
		{
RESOLVER.setLength($$.element,$length.res);
}
		(
			","
			decimals:IntLiteralWrapper
			{
RESOLVER.setDecimals($$.element,$decimals.res);
}
		)?
		")"
	)?
;

AnnotationTypeSpecNoColon
[IElementDeclaration element]
:
	type1 = annotationStructuredType[$$.element, null]
	|
	AnnotationTypeNamedOrEnum[$$.element]
;

AnnotationTypeArray
[IElementDeclaration element]
:
	arr: "array" arrof: "of"
	{
$$.element.setArrayToken(TOK(arr));
$$.element.setArrayOfToken(TOK(arrof));
}
	AnnotationTypeSpecNoColon[$$.element]
;

AnnotationTypeName //this rule name is used in BaseCdsDdlParser. Keep this in mind when re-name-ing or delete-ing this rule
returns [IPathExpression res]
:
	typeName=TypeName
	{
$$.res = $typeName.res;
}
;

annotationEnumClause
[IElementDeclaration element, IEnumerationValue val]
returns [IEnumerationDeclaration enumeration]
	@init{
		int startIndex = 0;
		int endIndex = 0;
	}
:
	DDL_ENUM
	{
$$.enumeration = RESOLVER.createAndSetEnumerationDeclaration($$.element);
}
	"{"
	(
		{
$$.val = RESOLVER.createAndSetEnumerationValue($$.enumeration);
$startIndex = RESOLVER.getNextTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.val,$startIndex,-1);
}
		symbol = IdWrapper
		{
$$.val.setSymbol($symbol.res);
}
		(
			"="
			lit = AnnotationLiteral
			{
$$.val.setLiteral(RESOLVER.viewparser_cliteral($lit.res));
}
		)  // in the backend this is mandatory
		{
if ($$.val.getLiteral() == null) {
var implicitSymbol = RESOLVER.viewparser_cliteral($symbol.res);
$$.val.setLiteral(implicitSymbol);
}
}
		";"
		{
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.val,$startIndex,$endIndex);
}
	)*
	"}"
;

annotationStructuredType
[IElementDeclaration element, IAnonymousTypeDeclaration type]
	@init{
		int startIndex = 0;
		int endIndex = 0;
		int typeStartIndex = 0;
		int typeEndIndex = 0;
	}
:

	{
$typeStartIndex = RESOLVER.getNextTokenIndex();
}

	"{"
	{
$$.type = RESOLVER.createAndSetAnonymousTypeDeclaration($$.element);
RESOLVER.viewparser_setStartEndTokenIndex($$.type,$typeStartIndex,-1);
}
	(
		{
$$.element = RESOLVER.createAndSetAttributeDeclaration($$.type);
$startIndex = RESOLVER.getNextTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.element,$startIndex,-1);
}
		name = IdWrapper {
$$.element.setNameToken($name.res);
}
		type = annotationTypeSpec[$$.element]
   		{
$endIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setEndTokenIndex($$.element,$endIndex);
}
	)*
	"}"

	{
$typeEndIndex = RESOLVER.getLastMatchedTokenIndex();
RESOLVER.viewparser_setStartEndTokenIndex($$.type,$typeStartIndex,$typeEndIndex);
}

	(
		";"
	)?
;


////////////////////////////////////////
// Preliminary keyword handling
////////////////////////////////////////

CONTEXT       								: "context"        						;
BETWEEN       								: "between"								;
DEFINE        								: "define"         						;
// take care of re-naming this rule name; its name is referenced in VersionsFactory#setErrorRecoveryHook
ENTITY        								: "entity"         						;
VIEW          								: "view"           						;
AS            								: "as"             						;
QUERY         								: "query"          						;
TYPE          								: "type"           						;
ELEMENT returns     [Token name]    	: e:"element" 	{
$$.name = TOK(e);
}	;
ESCAPE        								: "escape"								;
IN            								: "in"									;
IS								            : "is" 									;
KEY returns 		[Token name]    	: k:"key" 		{
$$.name = TOK(k);
}	;
LIKE returns   		[Token name]		: l:"like" 		{
$$.name = TOK(l);
}	;
NULLABLE returns 	[Token name]    	: n:"nullable" 	{
$$.name = TOK(n);
}	;
NAMESPACE     								: "namespace"      						;
OF            								: "of"             						;
ASSOCIATION   								: "association"    						;
TO            								: "to"             						;
SELECT        								: "select"         						;
FROM          								: "from"           						;
INTO          								: "into"           						;
WHERE         								: "where"          						;
AND           								: "and"            						;
OR            								: "or"             						;
NOT  returns 		[Token name]      : n:"not"		{
$$.name = TOK(n);
}	;
NULL returns 		[Token name]    	: %CCIGNORE n:"null"		{
$$.name = TOK(n);
}	;
DEFAULT       								: "default"								;
GROUP         								: "group" 								;
BY           		 						: "by"   								;
HAVING        								: "having"								;
ORDER         								: "order" 								;
ASC returns         [Token name]      : n:"asc"		{
$$.name = TOK(n);
}	;
DESC returns		[Token name]		: n:"desc" 		{
$$.name = TOK(n);
}	;
NULLS returns  		[Token name]		: n:"nulls"     {
$$.name = TOK(n);
}	;
FIRST returns  		[Token name]		: n:"first"		{
$$.name = TOK(n);
}	;
LAST  returns  		[Token name]		: n:"last"      {
$$.name = TOK(n);
}	;
DISTINCT returns	[Token name]		: n:"distinct"  {
$$.name = TOK(n);
}	;
COUNT  returns 		[Token name]		: n:"count"     {
$$.name = TOK(n);
}	;
MIN    returns 		[Token name]		: n:"min"       {
$$.name = TOK(n);
}	;
MAX    returns 		[Token name]		: n:"max"       {
$$.name = TOK(n);
}	;
SUM    returns 		[Token name]		: n:"sum"       {
$$.name = TOK(n);
}	;
AVG    returns 		[Token name]		: n:"avg"       {
$$.name = TOK(n);
}	;
STDDEV returns 		[Token name]		: n:"stddev"    {
$$.name = TOK(n);
}	;
VAR    returns 		[Token name]		: n:"var"       {
$$.name = TOK(n);
}	;
ALL    returns 		[Token name]		: n:"all"       {
$$.name = TOK(n);
}	;
//            : ""      ;