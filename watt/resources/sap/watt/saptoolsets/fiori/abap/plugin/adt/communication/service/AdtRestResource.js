/**
 * RequireJS module with API:
 * <ul>
 * <li>AdtRestResource.getInstance
 * <li>public methods of AdtRestResource
 * </ul>
 */
define( //Define this module as requireJS module and its dependencies to other requireJS modules
	[ "../util/AdtCheckUtil", "../util/AdtUrlUtil",  // //$NON-NLS-1$ //$NON-NLS-2$
		"../util/AdtErrorDataContentHandlerXml", "../util/AdtSecurityChecker" ], //$NON-NLS-1$
	function (AdtCheckUtil, AdtUrlUtil, AdtErrorDataContentHandlerXml, AdtSecurityCheckerFactory) {

		"use strict"; //$NON-NLS-1$

		// Special jqXHR.status value 0 (see http://stackoverflow.com/questions/3825581/does-an-http-status-code-of-0-have-any-meaning/26451773#26451773)
		var XML_HTTP_REQUEST_STATUS_ERROR = 0;

		// HTTP status codes (see RFC 7231 Section 6.1: http://tools.ietf.org/html/rfc7231#section-6.1)
		var HTTP_STATUS_OK = 200;
		var HTTP_STATUS_FORBIDDEN = 403;

		function AdtRestResourceFactory() {

			/**
			 * Creates and returns a new instance of the AdtRestResource
			 * for the page currently loaded in the browser window,
			 * i.e. for the ABAP remote server from which this page is loaded.
			 * <p>
			 * If a precondition check fails, e.g. in case of illegal arguments, then an exception is thrown: one error object {message, stack}.
			 * </p>
			 * Remark:<br>
			 * The ABAP server requires a CSRF-token for state-changing requests
			 * (PUT, POST, DELETE). The token is retrieved by a separate request from ABAP server
			 * and cached in the AdtRestResource.
			 * Therefore the caller should use the same AdtRestResource for all requests to the same server,
			 * so that double internal requests for retrieving the CSRF-token from this server are avoided.
			 * Remark: Security checks<br>
			 * The created <code>AdtRestResource</code> instance performs security checks for input validation. There
			 * are mandatory security checks which result in an error:
			 * <ul>
			 * <li>Not printable characters must not be contained in the request headers in the settings object.</li>
			 * <li>Username and password must be neither contained in the URL nor in the settings object.
			 * This also includes the query parameters “sap-user” and “sap-password”.</li>
			 * <li>Proprietary CSRF token handling is not allowed, because the CSRF token handling is done internally
			 * by the <code>AdtRestResource</code>.</li>
			 * </ul>
			 * Optional security checks can be controlled via the security property of the given <code>settings</code>
			 * object (see example below). The optional security checks can be executed in mode "strict" (they throw an
			 * error) or "info" (they write a warning into the console). Optional security checks are:
			 * <li>The <code>settings</code> object must not contain the setting for a synchronous request.</li>
			 * <li>The protocol must be HTTPS.</li>
			 * @param {object} settings - Optional settings parameter, e.g.
			 * {urlPrefix : "/destinations/my_server_abap_dev",
			 * security: {checkAsyncFalse: "strict", checkProtocolHTTPS: "info"}}
			 */
			this.createInstance = function (settings) {

				// WATT integration rules: Each service method has to return a promise.
				// But when the implementation does not return it, then this promise is automatically generated by the respective WATT proxy for the service.

				// Fail-Early-Approach for optional parameter
				if (settings && settings.urlPrefix) {
					AdtCheckUtil.checkStringArgumentIsNotEmpty("AdtRestResourceFactory.createInstance", "settings.urlPrefix", settings.urlPrefix);
				}
				return new AdtRestResource(settings);
			};
		}

		function AdtRestResource () {

			// Avoid double requests for getting the CSRF token: cache the qCSRFPromise
			// The promise used for initialization of CSRF token will fire callbacks for ever,
			// also when those callbacks are registered when the promise has already succeeded / failed.
			var qCSRFPromise = null;

			function isInitializingOrInitialized() {
				return qCSRFPromise !== null;
			}

			function resetCSRFToken() {
				qCSRFPromise = null;
			}

			var resourceSettings = arguments[0] || {}; // optional argument 'settings' of constructor

			var securitySettings = resourceSettings.security || {};
			var custSecurityChecker = AdtSecurityCheckerFactory.createInstance(securitySettings);

			var baseSecurityChecker = AdtSecurityCheckerFactory.createInstance({}); // only for the internal request retrieving the CSRF token

			var logger = (function () {

				// typeof missing reference === typeof existing reference with value undefined === "undefined"
				if (typeof window !== "undefined" && typeof window.console !== "undefined" && typeof window.console.warn !== "undefined") {
					return window.console;
				} else {
					// Use cases:
					// - window is not defined e.g. in Web Workers (Threading for JavaScript) (it is only available when a Web Worker defines its own window object, e.g. var window = self;  ...)
					// - the console methods are not standard, but browser-dependent (e.g. see https://developer.mozilla.org/en-US/docs/Web/API/Console)
					return new function () {
						this.warn = function () {
							// no op
						};
					};
				}
			})();

			this.__test__injectConsole = function (testConsole) { // actually private, but it is needed public for automatic tests

				logger = testConsole;
				AdtCheckUtil.__test__injectConsole(testConsole);
				custSecurityChecker.__test__injectConsole(testConsole);
				baseSecurityChecker.__test__injectConsole(testConsole);
			};

			/**
			 * This error can be made public if requested: this.AdtAjaxError = ... in AdtRestResourceFactory
			 */
			function AdtAjaxError(method, url, jqXHR, textStatus, errorThrown) {

				this.message = "Request [ " + method + " " + url + " ] failed: " + jqXHR.statusText;

				var constructedError = new Error(this.message);
				if (typeof constructedError.stack === "string") {
					this.stack = constructedError.stack;
				} else { // Problem on IE (e.g. IE 10, version 10.0.9200.17267):
					// IE does not produce a stack for an Error, when the constructor is called, but only when the error is thrown
					try {
						throw constructedError;
					} catch (thrownError) {
						this.stack = thrownError.stack;
						// Problem: see https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Error/stack
						// - IE provides the stack only starting with version 10.
						// - Safari provides the stack only starting with version 6.
					}
				}

				this.jqXHR = jqXHR;
				this.textStatus = textStatus;
				this.errorThrown = errorThrown;

				try {
					if (typeof this.constructor.name !== "string" || this.constructor.name !== "AdtAjaxError") {
						// Problem on IE (e.g. IE 10, version 10.0.9200.17267): IE does not provide the constructors name although it is a named function
						this.constructor.name = "AdtAjaxError";
					}
				} catch(e){
					// Problem on Chrome: In some situations this.constructor.name is not set and it is read-only.
					// Situations: when using config-preload in WebIDE (it works fine when using the debug flag in Web IDE or when debugging with Chrome)
					// Then it leads to the error: Unhandled Error: Cannot assign to read only property 'name' of function c(e,t,n,r,i){this.message="Request [ "+e+" "+t+" ] failed: "+n.statusText;var o=new Error(this.message...<omitted>...)}
				}
			}

			AdtAjaxError.prototype = new Error(); // use constructor, because create-method is not supported by all Browser versions: Object.create(Error.prototype);
			AdtAjaxError.prototype.constructor = AdtAjaxError;
			AdtAjaxError.prototype.name = "AdtAjaxError"; //$NON-NLS-1$


			/**
			 * The method fires the remote request defined by the given <code>settings</code> via jQuery.ajax.
			 * It collects all jQuery.ajax-callback-data:
			 * <ul>
			 *     <li> in success case: in 1 data-object {data, textStatus, jqXHR}</li>
			 *     <li> in failure case: in 1 error-object {jqXHR, textStatus, errorThrown}</li>
			 * </ul>
			 * and returns them in the promise-callbacks of the returned Q-promise as argument.
			 * @param {object} settings - The complete settings for the ajax-call (including method, url, ...)
			 * @returns {promise}
			 *          The resulting Q-promise
			 */
			function qWrappedJqAjax(settings, securityChecker) {

				// Fire request
				// ... and map the resulting jQuery-promise & its callback-data to a Q-promise & its callback-data
				// ... and prevent Q interprets the jQuery-promise jqXHR as a promise, that it shall resolve

				// Remark:
				// jQuery supports jqPromises with a success-callback and a fail-callback with 3 parameters:
				// jQueryPromise.then(
				//      function(data, textStatus, jqXHR){ ... },
				//      function(jqXHR, textStatus, errorThrown){ ... });
				// Unfortunately this cannot be exactly mapped to qPromise,
				// because Q only supports spreading to several single parameters for the success-callback,
				// but it does not support this for the fail-callback:
				//      see https://github.com/kriskowal/q/wiki/API-Reference, documentation for
				//          promise.spread(onFulfilled, onRejected).
				// Therefore we provide a mapping to qPromise-callbacks with 1 parameter, which is an object
				// containing the jQuery-callback parameters:
				// qPromise.then(
				//      function( result ){ ... }, // with result is an object {data, textStatus, jqXHR}
				//      function( error ){ ... }); // with error is an object {jqXHR, textStatus, errorThrown}
				var qDefer = Q.defer();

				var originalCsrfTokenHeader = settings.headers ? settings.headers["x-csrf-token"] : undefined;
				settings.beforeSend = getBeforeSendCallback(settings.beforeSend, originalCsrfTokenHeader, securityChecker);

				jQuery.ajax(settings) //
					.then( //
					function (data, textStatus, jqXHR) {
						delete jqXHR.then;
						qDefer.resolve({data: data, textStatus: textStatus, jqXHR: jqXHR});
					}, //
					function (jqXHR, textStatus, errorThrown) {
						delete jqXHR.then;
						var error = new AdtAjaxError(settings.type, settings.url, jqXHR, textStatus, errorThrown);
						qDefer.reject(error);
					});
				return qDefer.promise;
			}

			function addToStringMethodToJQXHR(jqXHR) {
				jqXHR.toString = function () { //
					return "{ " + "status: " + jqXHR.status + ", ... }"; //
				};
			}

			function addToStringMethodsToSuccessCallbackParam(param) {
				if (param && param.jqXHR) {
					addToStringMethodToJQXHR(param.jqXHR);
				}
				param.toString = function () {
					return "{ jqXHR: " + param.jqXHR //
						+ ", textStatus: " + param.textStatus //
						+ ", data: " + param.data + " }";
				};
			}

			function addToStringMethodsToFailureCallbackParam(param) {
				if (param && param.jqXHR) {
					addToStringMethodToJQXHR(param.jqXHR);
				}
				param.toString = function () {
					return "{ jqXHR: " + param.jqXHR //
						+ ", textStatus: " + param.textStatus //
						+ ", errorThrown: " + param.errorThrown //
						+ ", adtErrorData: " + param.adtErrorData + " }";
				};
			}

			function getBeforeSendCallback(originalBeforeSend, originalCsrfTokenHeader, securityChecker) {

				return function (jqXHR, settings) {
					// At runtime the settings object already contains this callback, but the originalSettings still contain the original callback
					if (typeof originalBeforeSend === "function") {
						originalBeforeSend(jqXHR, settings);
						// The security checker has to restore the original CSRF token header (which was set by AdtRestResource) again, when the originalBeforeSend callback has changed it
						securityChecker.checkAndCorrectCsrfTokenHeader(originalCsrfTokenHeader, settings);
					}
					// The security checker has to check the final request after all potential modifications by a potential beforeSend callback of the consumer of the AdtRestResource
					securityChecker.check(settings.type, settings);
				};
			}

			// The CSRF Token is needed for the communication with an ABAP remote server (all requests besides GET): authentication.
			function getCSRFToken(hostUrl) {

				// Avoid double requests for getting CSRF token
				if (isInitializingOrInitialized()) {
					return qCSRFPromise;
				}

				// Send a request to a RestResource, which is available in all versions of the remote server,
				// for getting the CSRF-Token from the response-header
				var settings = {
					type: "GET", //$NON-NLS-1$
					url: createUrlForGettingCSRFToken(hostUrl),
					cache: false, // jQuery adds a query-param "_=timestamp-val", so that each URL is different and the response cannot be taken from browser cache, proxy cache, ...
					headers: {"x-csrf-token": "fetch"}, //$NON-NLS-1$ //$NON-NLS-2$
					dataType: "xml", //$NON-NLS-1$
					crossDomain: true
				};

				qCSRFPromise = qWrappedJqAjax(settings, baseSecurityChecker) // qCSRFPromise is cached (see above)
					.then( //
					function (result) {
						var csrfToken = result.jqXHR.getResponseHeader("x-csrf-token"); //$NON-NLS-1$
						AdtCheckUtil.check(csrfToken.length !== 0, //
							"Security handling with CSRF token is not supported for public ICF services: ICF service '/sap/bc/adt'."); //$NON-NLS-1$
						return csrfToken;
					}, //
					function (error) {
						if (error.jqXHR.status !== XML_HTTP_REQUEST_STATUS_ERROR && error.jqXHR.status !== HTTP_STATUS_OK) {
							var contentType = error.jqXHR.getResponseHeader("content-type"); //$NON-NLS-1$
							if (contentType !== null && contentType.indexOf("application/xml") > -1) { //$NON-NLS-1$
								// Add ADT error handling if exception from remote server
								error.adtErrorData = AdtErrorDataContentHandlerXml.deserialize(error.jqXHR.responseText);
							}
						}
						resetCSRFToken(); // Afterwards a next trial is possible -> Do we need a timeout to prevent too frequent trials ?
						addToStringMethodsToFailureCallbackParam(error);
						throw error;
					}
				);
				return qCSRFPromise;
			}

			function invoke(method, settings) {

				if (settings.success !== undefined && settings.success !== null) {
					// Ensure that a potentially defined success callback is called for the data converted by a potentially defined content-handler
					var onSuccess = settings.success;
					settings.success = undefined;
				}
				// Security - Ensure valid HTTP methods (GET, PUT, POST, DELETE, HEAD)
				// The caller cannot manipulate the method, but has to call the API methods provided by AdtRestResource (get, put, post, delete) (head is not yet supported by ADT)
				settings.type = method;
				handleRequestFilters(method, settings);

				var qAjaxPromise = qWrappedJqAjax(settings, custSecurityChecker) //
					.then( //
					function (result) {
						handleResponseFilters(method, settings, result);

						// Add ADT content handling if specified
						if (settings.adtContentHandler !== undefined && settings.adtContentHandler !== null) {
							result.data = settings.adtContentHandler.serialize(result.data, result.jqXHR);
						}
						// Execute success-callback (for the converted data) if specified
						if (onSuccess !== undefined) {
							onSuccess(result);
						}
						addToStringMethodsToSuccessCallbackParam(result);
						return result;
					}, //
					function (error) {
						if (error.jqXHR.status !== XML_HTTP_REQUEST_STATUS_ERROR && error.jqXHR.status !== HTTP_STATUS_OK) {
							var contentType = error.jqXHR.getResponseHeader("content-type"); //$NON-NLS-1$
							if (contentType !== null && contentType.indexOf("application/xml") > -1) { //$NON-NLS-1$
								// Add ADT error handling if exception from remote server
								error.adtErrorData = AdtErrorDataContentHandlerXml.deserialize(error.jqXHR.responseText);
							}
						}
						addToStringMethodsToFailureCallbackParam(error);
						throw error;
					});
				return qAjaxPromise;
			}

			function invokeWithCSRFToken(method, url, settings) {

				var ajaxSettings = settings || {};

				if (typeof url === "string") { //$NON-NLS-1$
					AdtCheckUtil.checkStringArgumentIsNotEmpty("AdtRestResource." + method, "url", url); //$NON-NLS-1$ //$NON-NLS-2$
					// if param url is defined, then param settings is optional
					ajaxSettings.url = url;
				} else {
					// if param url is not defined, then param settings is mandatory
					AdtCheckUtil.checkArgumentIsDefinedAndNotNull("AdtRestResource." + method, "settings", url); //$NON-NLS-1$ //$NON-NLS-2$
					ajaxSettings = url; //only settings object, URL see in ajaxSettings.url
				}
				// AdtRestResource performs an internal CSRF token handling and does not allow external settings for the CSRF token handling
				custSecurityChecker.checkAndRefuseCSRFTokenHeader(method, ajaxSettings);

				var hostUrl = AdtUrlUtil.extractHostUrl(ajaxSettings.url);
				var qPromise = getCSRFToken(hostUrl);
				return qPromise.then(//
					function (csrfToken) {
						ajaxSettings.headers = ajaxSettings.headers || {};
						ajaxSettings.headers["x-csrf-token"] = csrfToken; //$NON-NLS-1$
						var qInvokePromise = invoke(method, ajaxSettings);
						// new callback-chain, independent of the callback-chain for the CSRF-token
						return qInvokePromise.then(
							function (result) {
								return result;
							},
							function (error) {

								if (error.jqXHR.status === HTTP_STATUS_FORBIDDEN && error.adtErrorData === undefined) {
									// The two potential error causes cannot be distinguished:
									// - outdated CSRF-token (the ABAP server requires a new authentication from the browser (new session))
									//   -> avoid that the user has to refresh the page: spend 1 retrial to get a new CSRF-token and to send the POST/PUT/DELETE request
									// - (rare) problems reported by the ICF framework (before the ADT framework is called)
									//   -> this 1 retrial does not harm ...
									resetCSRFToken(); // reset cache
									var qPromiseSecondTrial = getCSRFToken(hostUrl);
									return qPromiseSecondTrial.then(
										function (csrfTokenSecondTrial) {
											ajaxSettings.headers["x-csrf-token"] = csrfTokenSecondTrial; //$NON-NLS-1$
											var qInvokePromiseSecondTrial = invoke(method, ajaxSettings);
											// new callback-chain, independent of the callback-chain for the CSRF-token
											return qInvokePromiseSecondTrial;
										});
								} else {
									throw error;
								}
							}
						);
					},
					function (error) {
						// The CSRFToken could not be retrieved, e.g. because the ICF service /sap/bc/adt is defined as public service
						// (direct modification of that service or overruling by the settings of an assigned alias service).
						// A retrial will not help, it only helps to fix the ICF service definition on ABAP server.
						resetCSRFToken();
						throw error;
					}
				);
			}

			function createUrlForGettingCSRFToken(hostUrl) {

				if (typeof hostUrl === "string" && hostUrl !== "") {
					AdtCheckUtil.check( //
							typeof resourceSettings.urlPrefix !== "string" || hostUrl === resourceSettings.urlPrefix, //
							"AdtRestResource: inconsistent host URL and URL prefix: " + hostUrl + "!==" + resourceSettings.urlPrefix);
					var prefix = hostUrl;
				} else {
					prefix = resourceSettings.urlPrefix;
				}
				return AdtUrlUtil.ensureLeadingUriPrefix(prefix, "/sap/bc/adt/compatibility/graph");
			}

			function handleRequestFilters(method, settings) {
				// A set of registered request filters with dedicated API will be implemented in future. Then this handling will be improved.
				// Currently we need only the handling of a first internal request filter:
				requestFilterCheckUrlPrefix(method, settings);
			}

			function requestFilterCheckUrlPrefix(method, settings) {

				if (typeof resourceSettings.urlPrefix === "string" && resourceSettings.urlPrefix !== "") {
					var hostUrl = AdtUrlUtil.extractHostUrl(settings.url);
					if (typeof hostUrl === "string" && hostUrl !== "") { // Reason for this check: computation of URL for CSRF token retrieval
						AdtCheckUtil.check( //
								typeof resourceSettings.urlPrefix !== "string" || hostUrl === resourceSettings.urlPrefix, //
								"AdtRestResource: inconsistent host URL and URL prefix: " + hostUrl + "!==" + resourceSettings.urlPrefix);
					}
					settings.url = AdtUrlUtil.ensureLeadingUriPrefix(resourceSettings.urlPrefix, settings.url);
				}
			}

			function handleResponseFilters(method, settings, result) {
				// A set of registered response filters with dedicated API will be implemented in future. Then this handling will be improved.
				// Currently we need only the handling of a first internal response filter:
				responseFilterCheckAcceptHeader(method, settings, result);
			}

			function responseFilterCheckAcceptHeader(method, settings, result) {

				if ((result.jqXHR.status >= 200 && result.jqXHR.status < 300) // request succeeds
					&& (result.data !== undefined && result.data !== null)) {// response body filled
					if (settings.headers === undefined || settings.headers === null // request headers are defined
						|| settings.headers["Accept"] === undefined || settings.headers["Accept"] === null) {  //$NON-NLS-1$//$NON-NLS-2$
						// accept-header is not defined, see http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
						logger.warn(
								"Request \"" + settings.type + " " + settings.url + "\" resulted in a response with a body. The request did not specify acceptable content types via the accept header. This can lead to client/server compatibility problems."); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
					}
				}
			}

			/**
			 * Invokes an HTTP GET method on the given <code>url</code>.
			 * The GET request is performed asynchronously or synchronously,
			 * as it is defined in the given jQuery ajax <code>settings</code>.
			 * <p>
			 * Independently of the settings, the method returns a Q-promise, which asynchronously calls the respective
			 * callback functions:
			 * <ul>
			 * <li> API of done-callback: function( result ) with result is one object {data, textStatus, jqXHR}</li>
			 * <li> API of fail-callback: function( error ) with error is one object {jqXHR, textStatus, errorThrown, adtErrorData}</li>
			 * <li> with data, textStatus, jqXHR, errorThrown are the parameters provided in
			 * the callback functions of the jQuery ajax call,</li>
			 * <li> if an error came up on ABAP server, then adtErrorData is available and contains the respective error data.</li>
			 * </ul>
			 * If a precondition check fails, e.g. in case of illegal arguments, then an exception is thrown: one error object {message, stack}.
			 * </p>
			 * <p>
			 * In case a success callback is provided via the given jQuery ajax <code>settings</code>,
			 * then this callback must fulfill the API of a Q-promise success-callback, as described above.
			 * </p>
			 * <p>
			 * The method performs security checks as input validation as it was configured when the <code>AdtRestResource</code>
			 * was created (see JSDoc of <code>AdtRestResourceFactory#createInstance</code>).
			 * </p>
			 *
			 * @param {string} url - Rest resource URL (optional)
			 * @param {object} settings - Settings for ajax call. Type: plain object, see jQuery.ajax() for more details.
			 *                                  If only the settings parameter is given, then the relative URL has to
			 *                                  be provided via settings.url.
			 * @returns {Promise} a Q-promise
			 */
			this.get = function (url, settings) {

				var ajaxSettings;
				if (typeof url === "string") { //$NON-NLS-1$
					AdtCheckUtil.checkStringArgumentIsNotEmpty("AdtRestResource.get", "url", url); //$NON-NLS-1$ //$NON-NLS-2$
					// if param url is defined, then param settings is optional
					ajaxSettings = settings || {};
					ajaxSettings.url = url;
				} else {
					// if param url is not specified, then param settings is mandatory
					AdtCheckUtil.checkArgumentIsDefinedAndNotNull("AdtRestResource.get", "settings", url); //$NON-NLS-1$ //$NON-NLS-2$
					ajaxSettings = url;
				}
				// AdtRestResource performs an internal CSRF token handling and does not allow external settings for the CSRF token handling
				custSecurityChecker.checkAndRefuseCSRFTokenHeader("GET", ajaxSettings);

				return invoke("GET", ajaxSettings); //$NON-NLS-1$
			};

			/**
			 * Invokes an HTTP POST method on the given <code>url</code>.
			 * The POST request is performed asynchronously or synchronously,
			 * as it is defined in the given jQuery ajax <code>settings</code>.
			 * <p>
			 * Independently of the settings, the method returns a Q-promise, which asynchronously calls the respective
			 * callback functions:
			 * <ul>
			 * <li> API of done-callback: function( result ) with result is one object {data, textStatus, jqXHR}</li>
			 * <li> API of fail-callback: function( error ) with error is one object {jqXHR, textStatus, errorThrown, adtErrorData}</li>
			 * <li> with data, textStatus, jqXHR, errorThrown are the parameters provided in
			 * the callback functions of the jQuery ajax call,</li>
			 * <li> if an error came up on ABAP server, then adtErrorData is available and contains the respective error data.</li>
			 * </ul>
			 * If a precondition check fails, e.g. in case of illegal arguments, then an exception is thrown: one error object {message, stack}.
			 * </p>
			 * <p>
			 * In case a success callback is provided via the given jQuery ajax <code>settings</code>,
			 * then this callback must fulfill the API of a Q-promise success-callback, as described above.
			 * </p>
			 * Remark:<br>
			 * If the Http status of the ABAP server response is 403 (FORBIDDEN), then the CSRF-token might be outdated.
			 * In this case the method retries to retrieve a new CSRF-token and retries the POST request one further time.
			 * <p>
			 * The method performs security checks as input validation as it was configured when the <code>AdtRestResource</code>
			 * was created (see JSDoc of <code>AdtRestResourceFactory#createInstance</code>).
			 * </p>
			 *
			 * @param {string} url - Rest resource URL (optional)
			 * @param {object} settings - Settings for ajax call. Type: plain object, see jQuery.ajax() for more details.
			 *                                  If only the settings parameter is given, then the relative URL has to
			 *                                  be provided via settings.url.
			 * @returns {Promise} a Q-promise
			 */
			this.post = function (url, settings) {
				return invokeWithCSRFToken("POST", url, settings); //$NON-NLS-1$
			};

			/**
			 * Invokes an HTTP PUT method on the given <code>url</code>.
			 * The PUT request is performed asynchronously or synchronously,
			 * as it is defined in the given jQuery ajax <code>settings</code>.
			 * <p>
			 * Independently of the settings, the method returns a Q-promise, which asynchronously calls the respective
			 * callback functions:
			 * <ul>
			 * <li> API of done-callback: function( result ) with result is one object {data, textStatus, jqXHR}</li>
			 * <li> API of fail-callback: function( error ) with error is one object {jqXHR, textStatus, errorThrown, adtErrorData}</li>
			 * <li> with data, textStatus, jqXHR, errorThrown are the parameters provided in
			 * the callback functions of the jQuery ajax call,</li>
			 * <li> if an error came up on ABAP server, then adtErrorData is available and contains the respective error data.</li>
			 * </ul>
			 * If a precondition check fails, e.g. in case of illegal arguments, then an exception is thrown: one error object {message, stack}.
			 * </p>
			 * <p>
			 * In case a success callback is provided via the given jQuery ajax <code>settings</code>,
			 * then this callback must fulfill the API of a Q-promise success-callback, as described above.
			 * </p>
			 * Remark:<br>
			 * If the Http status of the ABAP server response is 403 (FORBIDDEN), then the CSRF-token might be outdated.
			 * In this case the method retries to retrieve a new CSRF-token and retries the PUT request one further time.
			 * <p>
			 * The method performs security checks as input validation as it was configured when the <code>AdtRestResource</code>
			 * was created (see JSDoc of <code>AdtRestResourceFactory#createInstance</code>).
			 * </p>
			 *
			 * @param {string} url - Rest resource URL (optional)
			 * @param {object} settings - Settings for ajax call. Type: plain object, see jQuery.ajax() for more details.
			 *                                  If only the settings parameter is given, then the relative URL has to
			 *                                  be provided via settings.url.
			 * @returns {Promise} a Q-promise
			 */
			this.put = function (url, settings) {
				return invokeWithCSRFToken("PUT", url, settings); //$NON-NLS-1$
			};

			/**
			 * Invokes an HTTP DELETE method on the given <code>url</code>.
			 * The DELETE request is performed asynchronously or synchronously,
			 * as it is defined in the given jQuery ajax <code>settings</code>.
			 * <p>
			 * Independently of the settings, the method returns a Q-promise, which asynchronously calls the respective
			 * callback functions:
			 * <ul>
			 * <li> API of done-callback: function( result ) with result is one object {data, textStatus, jqXHR}</li>
			 * <li> API of fail-callback: function( error ) with error is one object {jqXHR, textStatus, errorThrown, adtErrorData}</li>
			 * <li> with data, textStatus, jqXHR, errorThrown are the parameters provided in
			 * the callback functions of the jQuery ajax call,</li>
			 * <li> if an error came up on ABAP server, then adtErrorData is available and contains the respective error data.</li>
			 * </ul>
			 * If a precondition check fails, e.g. in case of illegal arguments, then an exception is thrown: one error object {message, stack}.
			 * </p>
			 * <p>
			 * In case a success callback is provided via the given jQuery ajax <code>settings</code>,
			 * then this callback must fulfill the API of a Q-promise success-callback, as described above.
			 * </p>
			 * Remark:<br>
			 * If the Http status of the ABAP server response is 403 (FORBIDDEN), then the CSRF-token might be outdated.
			 * In this case the method retries to retrieve a new CSRF-token and retries the DELETE request one further time.
			 * <p>
			 * The method performs security checks as input validation as it was configured when the <code>AdtRestResource</code>
			 * was created (see JSDoc of <code>AdtRestResourceFactory#createInstance</code>).
			 * </p>
			 *
			 * @param {string} url - Rest resource URL (optional)
			 * @param {object} settings - Settings for ajax call. Type: plain object, see jQuery.ajax() for more details.
			 *                                  If only the settings parameter is given, then the relative URL has to
			 *                                  be provided via settings.url.
			 * @returns {Promise} a Q-promise
			 */
			this.del = function (url, settings) { //delete is a keyword in JavaScript so we are forced to use a shorter name
				return invokeWithCSRFToken("DELETE", url, settings); //$NON-NLS-1$
			};
		}

		return new AdtRestResourceFactory(); // requireJS module
	});